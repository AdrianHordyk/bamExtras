b <- gsub("(.*)(.D)$","D.\\1",a) # Convert .D suffix to D. prefix
c <- gsub("^([cr])(.*)","L.\\1\\2",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
# predicted
lcomp_b_pr <- rdat$comp.mats[grepl("^lcomp.*.pr$",names(rdat$comp.mats))]
names(lcomp_b_pr) <- local({
a <- gsub("^(lcomp.)(.*)(.pr)$","\\2",names(lcomp_b_pr))
b <- gsub("(.*)(.D)$","D.\\1",a) # Convert .D suffix to D. prefix
c <- gsub("^([cr])(.*)","L.\\1\\2",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
lenprob <- list()
## Build age-length conversion matrix associated with each set of length comps
## (will often be the same for all comps)
for(i in 1:length(lcomp_b_pr)){
avail_len_cv_val <- names(rdat$parm.cons)[grepl("^len.cv",names(rdat$parm.cons))]
if(length(avail_len_cv_val)>1){
message(paste("message: found multiple len.cv.val in rdat:",paste(avail_len_cv_val,collapse=", "),"Currently only using len.cv.val"))
}
len_cv_val_i <- rdat$parm.cons$len.cv.val[8]
len_sd_i <- len*len_cv_val_i
lc_i <- lcomp_b_pr[[i]]
lc_bm_i <- as.numeric(colnames(lc_i))  # bin mid point
lc_bw_i <- median(diff(lc_bm_i)) # bin width
lc_bl_i <- lc_bm_i-lc_bw_i/2  # bin lo (minimum)
lenprob_i <- local({
mat_i <- matrix(NA,nrow=length(ages),ncol=length(lc_bm_i),dimnames = list("age"=ages,"lenbin"=lc_bm_i))
mat_i[,1] <- pnorm((lc_bl_i[2]-len)/len_sd_i)
for(i in 2:(ncol(mat_i)-1)){
mat_i[,i] <- pnorm((lc_bl_i[i+1]-len)/len_sd_i)-pnorm((lc_bl_i[i]-len)/len_sd_i)
}
mat_i[,ncol(mat_i)] <- 1-rowSums(mat_i[,1:(ncol(mat_i)-1)])
mat_i
})
lenprob[[i]] <- lenprob_i
}
names(lenprob) <- names(lcomp_b_pr)
## Recompute predicted age and length comps
# Note: These should be the same or very similar to age and length comps computed by BAM.
#  But these are recomputed for the base years as a check since the computation
#  will be used in the projection years
# acomp_b_pr_2 <-  list()
# for(nm_i in names(acomp_b_pr)){
#   yrs_ac_i <- rownames(acomp_b_pr[[nm_i]])
#   if(grepl("^[LD]",nm_i)){ # If length comps are associated with catch (landings or discards), used numbers from landings
#     n_i <- Cn[[paste0("Cn.",nm_i)]][yrs_ac_i,]
#   }else{
#     n_i <- NU[[nm_i]][yrs_ac_i,] # If not (i.e. it's a fishery independent survey) use numbers associated with the index
#   }
#   P_n_i <- t(apply(n_i,1,function(x){x/sum(x)}))
#   acomp_b_pr_2_i <- t(apply(P_n_i,1,function(x){colSums(x*age_error)}))
#   acomp_b_pr_2[[nm_i]] <- acomp_b_pr_2_i
# }
# lcomp_b_pr_2 <-  list()
# for(nm_i in names(lcomp_b_pr)){
#   yrs_lc_i <- rownames(lcomp_b_pr[[nm_i]])
#   lenprob_i <- lenprob[[nm_i]]
#   if(grepl("^[LD]",nm_i)){ # If length comps are associated with catch (landings or discards), used numbers from landings
#     n_i <- Cn[[paste0("Cn.",nm_i)]][yrs_lc_i,]
#   }else{
#     n_i <- NU[[nm_i]][yrs_lc_i,] # If not (i.e. it's a fishery independent survey) use numbers associated with the index
#   }
#   P_n_i <- t(apply(n_i,1,function(x){x/sum(x)}))
#   lcomp_b_pr_2_i <- t(apply(P_n_i,1,function(x){colSums(x*lenprob_i)}))
#   lcomp_b_pr_2[[nm_i]] <- lcomp_2_i
# }
##
# number of trips in compositions
ntrip <- t.series[paste(yb),grepl("^([la]comp).*(.n)$",names(t.series))]
ntrip[ntrip==-99999] <- NA
names(ntrip) <- local({
a <- gsub("(.n)$","",names(ntrip))
b <- gsub("^([al]comp.)(.*)(.)(D)$","\\1D.\\2",a) # Convert .D suffix to D. prefix
c <- gsub("^([al]comp.)([cr])(.*)","\\1L.\\2\\3",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
# number of fish in compositions
nfish <- t.series[paste(yb),grepl("^([la]comp).*(.nfish)$",names(t.series))]
nfish[nfish==-99999] <- NA
names(nfish) <- local({
a <- gsub("(.nfish)$","",names(nfish))
b <- gsub("^([al]comp.)(.*)(.)(D)$","\\1D.\\2",a) # Convert .D suffix to D. prefix
c <- gsub("^([al]comp.)([cr])(.*)","\\1L.\\2\\3",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
#Initial conditions
#Recruits in yr 1 constrained to S-R curve, or else varies in stochastic runs
if(is.null(N_styr_proj)){N_styr_proj <- tail(rdat$N.age,1)}
N_endyr <- rdat$N.age[paste(endyr),]
if(is.null(S_styr_proj)){
S_styr_proj <- local({
Z_styr_proj <- rdat$Z.age[paste(endyr),]
N_endyr_spn <- N_endyr*exp(-1.0*Z_styr_proj*spawn_time)
sum(N_endyr_spn*reprod)
})
}
if(SR_method=="BH"){
if(is.null(SR_par)){
h <-        rdat$parms$BH.steep
R0 <-       rdat$parms$BH.R0
Phi0 <-     rdat$parms$BH.Phi0
biascorr <- rdat$parms$BH.biascorr
}else{
for(i in 1:length(SR_par)){xi <- SR_par[i]; assign(x=names(xi),value=xi)}
}
SR_par_null <- c("h","R0","Phi0","biascorr")[c(is.null(h),is.null(R0),is.null(Phi0),is.null(biascorr))]
# If not all of the BH SR parameters are found, resort to using the GM method
if(length(SR_par_null)>0){
message(paste("message: BH SR parameters not found:",paste(SR_par_null,collapse=", ")," Using SR_method = GM.\n"))
SR_method <- "GM"
}else{
message("message: all BH SR parameters found. Using SR_method = BH.\n")
}
}else{
message(paste("message: Using SR_method = GM.\n"))
}
if(is.null(M)){
M <- a.series$M
}
# } # end if(!is.null(rdat))
source("~/GitHub/myPackages/bamExtras/TEST_FOLDER/run_proj/run_proj_test_args.r", echo=TRUE)
library(ggplot2)
library(tidyr)
if(!is.null(run_bam_args)){
if(!"return_obj"%in%names(run_bam_args)){
run_bam_args <- c(run_bam_args,list(return_obj=c("dat","tpl","cxx","rdat")))
}
run_bam_out <- do.call(run_bam,run_bam_args)
rdat <- run_bam_out$rdat
}
# if(!is.null(rdat)){
styr <- rdat$parms$styr
endyr <- rdat$parms$endyr
yb <- styr:endyr # years of the base model
a.series <- rdat$a.series
t.series <- rdat$t.series
sel_age <- rdat$sel.age
yrs_L_b <- paste((endyr-(nyb$L-1)):endyr) # years of recent landings (i.e. from the base model)
yrs_R_b <- paste((endyr-(nyb$R-1)):endyr)
R_b <- t.series[yrs_R_b,"recruits"]
R_b_gm <- bamExtras::geomean2(R_b)
# Identify F-at-age for each fleet in endyr
# L = (F/Z)*N*(1-exp(-Z))
# L/(N*(1-exp(-Z))) = F/Z
# L*Z/(N*(1-exp(-Z))) = F
# F = L*Z/(N*(1-exp(-Z)))
Cn <- rdat$CLD.est.mats[names(rdat$CLD.est.mats)[grepl("^(Ln|Dn)((?!total).)*$",names(rdat$CLD.est.mats),perl=TRUE)]]
names(Cn) <- gsub("^([LD])(n)(.*)","Cn.\\1\\3",names(Cn))
Cw <- rdat$CLD.est.mats[names(rdat$CLD.est.mats)[grepl("^(Lw|Dw)((?!total).)*$",names(rdat$CLD.est.mats),perl=TRUE)]]
names(Cw) <- gsub("^([LD])(w)(.*)","Cw.\\1\\3",names(Cw))
C_ts_cv <- t.series[paste(yb),grepl("^cv.[DL]",names(t.series))] # cvs associated with components of the catch (removals) during the base years
Z <- rdat$Z.age[paste(yb),]
N <- rdat$N.age[paste(yb),]
Nmdyr <- rdat$N.age.mdyr[paste(yb),]
R <- N[,1] # Recruits
# Like F_fleet in bam tpl (e.g. F_cHL). Same computation as bam
F_flt <- lapply(Cn,function(x){x*Z/(N*(1-exp(-Z)))}) # Computes a list of F (year,age) for each fleet, which are not in the rdat
# names(F_flt) <- paste("F",gsub("([LD])(n)(.*)","\\1\\3",names(F_flt)),sep=".")
names(F_flt) <- gsub("^Cn","F",names(F_flt))
if(is.null(ages)){ages <- a.series$age}
nages <- length(ages)
len <- rdat$a.series$length
if(is.null(age_error)){age_error <- rdat$age.error$error.mat
if(is.null(age_error)){ # If there is no age error matrix in the rdat, just use an identity matrix
age_error <- diag(length(ages))
dimnames(age_error) <- list("age"=ages,"age"=ages)
age_error
}
}
if(is.null(spawn_time)){spawn_time <- rdat$parms$spawn.time}
if(is.null(reprod)){reprod <- a.series$reprod}
if(is.null(styr_proj)){styr_proj <- endyr+1}
yp <- styr_proj:(styr_proj+nyp-1) # years of the projection period
if(is.null(F_cur)){F_cur <- bamExtras::geomean2(t.series[yrs_L_b,"F.full"],na.rm=TRUE)}
if(is.null(F_proj)){F_proj <- rdat$parms$Fmsy}
if(is.null(L_cur)){
is.total.L.klb <- "total.L.klb"%in%names(t.series)
if(!is.total.L.klb){
total.L.name <- names(t.series)[grepl("total.L",names(t.series))][1]
message(paste("message: total.L.klb not found in t.series. L_cur is computed from",total.L.name,"instead\n"))
total.L <- t.series[,total.L.name,drop=FALSE]
}else{
total.L <- t.series[,"total.L.klb",drop=FALSE]
message(paste("message: L_cur is computed from t.series$total.L.klb\n"))
}
L_cur <- mean(total.L[yrs_L_b,])
}
if(is.null(sel_L)){sel_L <- sel_age$sel.v.wgted.L}
if(is.null(sel_D)){
if(!is.null(sel_age$sel.v.wgted.D)){
sel_D <- sel_age$sel.v.wgted.D
}else{
message("message: sel_age$sel.v.wgted.D not found. Assessment may not model discards?\n")
}
}
if(is.null(sel_tot)){sel_tot <- sel_age$sel.v.wgted.tot}
if(is.null(sel_F_flt)){
LD_abb <- gsub(".pr$","",names(t.series)[grepl("^[LD].*.pr$",names(t.series),perl=TRUE)]) # landings abbreviations
LD_abb_ts <- paste0("F.",gsub("^(D.)(.*)","\\2.D",gsub("^L.","",LD_abb)))
Fsum_flt <- t.series[paste(yb),LD_abb_ts] # F time series for each fleet
names(Fsum_flt) <- paste0("F.",LD_abb)
Fsum <- rowSums(Fsum_flt) # Should be equal to t.series$Fsum
# Compute selectivity for each fleet associated with an F value.
# NOTE: Computing selectivities is somewhat more reliable than trying to find
# then in the rdat, in instances when selectivities from one fleet are used
# for multiple fleets (e.g. when the headboat selectivity is used for the MRIP landings)
sel_F_flt <- lapply(names(F_flt),function(x){
a <- pmax(pmin(F_flt[[x]]/Fsum_flt[,x],1),0)
a[is.na(a)] <- 0 # Replace NA with zero (NaN will occur when Fsum_flt values are zero, as in years when fleets do not have any landings)
a
})
names(sel_F_flt) <- gsub("^F.","sel.",names(F_flt))
F_ybgm_flt <- apply(tail(Fsum_flt,nyb$L),2,bamExtras::geomean2) # geomean F by fleet during the last nyb years of the base model
F_prop_flt <- F_ybgm_flt/sum(F_ybgm_flt) # Proportion of F attributed to each fleet at the end of the assessment
# This is just F_ybgm_flt multiplied by the selectivity in the endyr of the base model for each fleet
# In the bam tpl, these vectors are named F_end although they are summed by landings (F_end_L), discards (F_end_D), or both (F_end)
F_ybgm_flt_a <- as.data.frame(
lapply(1:length(sel_F_flt),function(i){
nm_x <- names(sel_F_flt)[i]
sel_endyr_x <- sel_F_flt[[nm_x]][paste(endyr),]
F_ybgm_flt_x <- F_ybgm_flt[[gsub("^sel.","F.",nm_x)]]
F_ybgm_flt_x*sel_endyr_x
}
)
)
names(F_ybgm_flt_a) <- names(F_ybgm_flt)
# Sum across fleets (these objects are named as in bam tpl)
F_end_L <- rowSums(F_ybgm_flt_a[grepl("^F.L",names(F_ybgm_flt_a))])
F_end_D <- rowSums(F_ybgm_flt_a[grepl("^F.D",names(F_ybgm_flt_a))])
F_end <- rowSums(as.data.frame(F_ybgm_flt_a))
F_end_apex <- max(F_end)
sel_wgted_tot <- F_end/F_end_apex # Should equal to rdat$sel.age$sel.v.wgted.tot
sel_wgted_L <-   sel_wgted_tot*(F_end_L/F_end) # Should equal rdat$sel.age$sel.v.wgted.L # F_end_L/F_end_apex # as in tpl
sel_wgted_D <-   sel_wgted_tot*(F_end_D/F_end) # Should equal rdat$sel.age$sel.v.wgted.D # F_end_D/F_end_apex # as in tpl
sel_wgted_F_flt <- F_ybgm_flt_a/F_end_apex     # by extension, scale selectivity at age for each fleet
# Note that: round((sel_wgted_L+sel_wgted_D) == rowSums(sel_wgted_F_flt)
}
## Weights of fish (year, age)
if(is.null(wgt)){wgt <- a.series$wgt.mt}
if(is.null(wgt_L)){
if(!is.null(a.series$wholewgt.wgted.L.klb)){
wgt_L <- a.series$wholewgt.wgted.L.klb
message("message: wgt_L set equal to a.series$wholewgt.wgted.L.klb\n")
}else if(!is.null(a.series$gutwgt.wgted.L.klb)){
wgt_L <- a.series$gutwgt.wgted.L.klb
message("message: wgt_L set equal to a.series$gutwgt.wgted.L.klb\n")
}
}
if(is.null(wgt_D)){
if(!is.null(a.series$wholewgt.wgted.D.klb)){
wgt_D <- a.series$wholewgt.wgted.D.klb
}else{
message("message: a.series$wholewgt.wgted.D.klb not found. Assessment may not model discards.\n")
}
}
## Weights of fish (year, age) by fleet.
if(is.null(wgt_F_flt)){
wgt_F_flt <- rdat$size.age.fishery[grepl("^[a-zA_Z].*wgt",names(rdat$size.age.fishery))]
# Reformat names to wgt.fleetType.fleet
# (e.g. wgt.L.cHL for weight of landings in the commercial hook and line fleet)
wgt_F_flt_abb <- local({
a <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\3",names(wgt_F_flt),perl=TRUE)
gsub("^([^D.])([a-zA-Z]+)","L.\\1\\2",gsub("(.*?)(?<=.)(.D)$","D.\\1",a,perl=TRUE))
})
wgt_F_flt_units <- local({
a <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\1.\\5",names(wgt_F_flt),perl=TRUE)
# a <- gsub("wgt","W",a)
# a <- gsub("whole","W",a)
# a <- gsub("gut","G",a)
return(a)
})
names(wgt_F_flt) <- names(wgt_F_flt_units) <- paste("wgt", #wgt_F_flt_units,
wgt_F_flt_abb,sep=".")
# Convert weights in lb to klb
for(nm_i in names(wgt_F_flt)){
xi <- wgt_F_flt[[nm_i]]
if(grepl(".lb$",wgt_F_flt_units[[nm_i]])){
wgt_F_flt[[nm_i]] <- xi/1000
wgt_F_flt_units[[nm_i]] <- gsub(".lb$",".klb",wgt_F_flt_units[[nm_i]])
}
}
}
# Lengths of fish (year, age) by fleet.
if(is.null(len_F_flt)){
len_F_flt <- rdat$size.age.fishery[grepl("^[a-zA_Z]*.*len",names(rdat$size.age.fishery))]
# Reformat names to len.fleetType.fleet
# (e.g. len.L.cHL for length of landings in the commercial hook and line fleet)
len_F_flt_abb <- local({
a <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\3",names(len_F_flt),perl=TRUE)
gsub("^([^D.])([a-zA-Z]+)","L.\\1\\2",gsub("(.*?)(?<=.)(.D)$","D.\\1",a,perl=TRUE))
})
len_F_flt_units <- local({
a <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\1.\\5",names(len_F_flt),perl=TRUE)
# a <- gsub("len","W",a)
# a <- gsub("whole","W",a)
# a <- gsub("gut","G",a)
return(a)
})
names(len_F_flt) <- names(len_F_flt_units) <- paste("len", #len_F_flt_units,
len_F_flt_abb,sep=".")
}
# Recompute landings by fleet to compare with calculations used in projections
Cn2 <- lapply(Cn,function(x){x*NA})
Cw2 <- lapply(Cw,function(x){x*NA})
for(i in 1:length(yb)){
for(j in 1:ncol(Fsum_flt)){
Cn2[[j]][i,] <- L_calc(F_flt[[j]][i,], Z[i,], N[i,])
Cw2[[j]][i,] <- L_calc(F_flt[[j]][i,], Z[i,], N[i,], wgt_F_flt[[j]][i])
}
}
# CPUE
#   From bam tpl for SEDAR53:
#     N_cHL(iyear)=elem_prod(elem_prod(Nmdyr(iyear),sel_cHL(iyear)),wholewgt_cHL_klb(iyear));
#     pred_cHL_cpue(iyear)=q_cHL(iyear)*q_rate_fcn_cHL(iyear)*q_DD_fcn(iyear)*sum(N_cHL(iyear));
U_a <- list()
NU <- list()
wgt_U <- list()
U_ts <- t.series[paste(yb),grepl("^U.*pr$",names(t.series)),drop=FALSE]
U_ts_cv <- t.series[paste(yb),grepl("^cv.U",names(t.series)),drop=FALSE] # cvs associated with U during the base years
# names(U_ts) <- gsub("^(U.)(.*)(.)(pr)$","\\1\\4.\\2",names(U_ts))
U_abb <- gsub("^U.|.pr$","",names(U_ts))
names(U_ts) <- U_abb
q_mn <- t.series[paste(yb),paste0("q.",U_abb),drop=FALSE]  # This is really a kind of mean q, since q_rate and q_DD_mult might scale it to compute U
q_DD_mult <- t.series[paste(yb),"q.DD.mult",drop=FALSE] # density dependent function as a multiple of q (scaled a la Katsukawa and Matsuda. 2003)
q_rate <- q_mn*0+1
q <- q_mn*NA # Initialize values for final q value (q_mn * q_rate * q_DD_mult) multiplied by N to compute CPUE
sel_U <- sel_age[which(gsub("sel.[vm].|(wgted.)","",names(sel_age))%in%U_abb)]
names(sel_U) <- U_abb
for(i in 1:length(sel_U)){
sel_U_i <- sel_U[[i]]
sel_nm_i <- names(sel_U)[i]
sel_abb_i <- gsub("sel.[vm].","",sel_nm_i)
q_nm_i <- paste0("q.",sel_abb_i)
U_type_i <- gsub("^wgt.(L.)?","",sel_abb_i) # 2023-1-10 I'm not sure this gsub is necessary anymore
wgt_U_i <- local({ # Set default wgt = 1
a <- sel_U_i
a*0+1
})
# If the U type is commercial, compute N_fleet in weight
if(gsub("^(.{1})(.*)","\\1",U_type_i)=="c"){
wgt_U_nm_i <- paste0("wgt.L.",sel_abb_i)
if(wgt_U_nm_i%in%names(wgt_F_flt)){
wgt_U_i <- wgt_F_flt[[paste0("wgt.L.",sel_abb_i)]]
}else{
message(paste("message: I could not find",wgt_U_nm_i, "to multiply by", sel_nm_i,"when computing", paste0("N_",sel_abb_i,"."), paste0("U_pr_",sel_abb_i), "will be computed in numbers instead of weight.\n"))
}
}
NU_i <- Nmdyr*sel_U_i*wgt_U_i
NU[[i]] <- NU_i
q_mn_i <- q_mn[paste(yb),q_nm_i,drop=FALSE]
q_rate_nm_i <- paste0("q.",sel_abb_i,".rate.mult")
if(q_rate_nm_i%in%names(t.series)){
q_rate_i <- t.series[paste(yb),q_rate_nm_i,drop=FALSE]
}else{
q_rate_i <- q_mn_i*0+1
message(paste("message:",q_rate_nm_i,"not found in t.series. Setting q rate multiplier values to 1.\n"))
}
q_rate[,q_nm_i] <- q_rate_i
q_i <- q_mn_i*q_rate_i*q_DD_mult
q[,q_nm_i] <- q_i
U_a_i <- unlist(q_i)*NU_i
U_a[[i]] <- U_a_i
wgt_U[[i]] <- wgt_U_i
# U_pr_i <- rowSums(U_a_i)
}
names(U_a) <- names(wgt_U) <- names(NU) <- U_abb
U <- as.data.frame(lapply(U_a,rowSums))
## age compositions from the base years
# observed
acomp_b_ob <- rdat$comp.mats[grepl("^acomp.*.ob$",names(rdat$comp.mats))]
names(acomp_b_ob) <- local({
a <- gsub("^(acomp.)(.*)(.ob)$","\\2",names(acomp_b_ob))
b <- gsub("(.*)(.D)$","D.\\1",a) # Convert .D suffix to D. prefix
c <- gsub("^([cr])(.*)","L.\\1\\2",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
# predicted
acomp_b_pr <- rdat$comp.mats[grepl("^acomp.*.pr$",names(rdat$comp.mats))]
names(acomp_b_pr) <- local({
a <- gsub("^(acomp.)(.*)(.pr)$","\\2",names(acomp_b_pr))
b <- gsub("(.*)(.D)$","D.\\1",a) # Convert .D suffix to D. prefix
c <- gsub("^([cr])(.*)","L.\\1\\2",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
## length compositions from the base years
# observed
lcomp_b_ob <- rdat$comp.mats[grepl("^lcomp.*.ob$",names(rdat$comp.mats))]
names(lcomp_b_ob) <- local({
a <- gsub("^(lcomp.)(.*)(.ob)$","\\2",names(lcomp_b_ob))
b <- gsub("(.*)(.D)$","D.\\1",a) # Convert .D suffix to D. prefix
c <- gsub("^([cr])(.*)","L.\\1\\2",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
# predicted
lcomp_b_pr <- rdat$comp.mats[grepl("^lcomp.*.pr$",names(rdat$comp.mats))]
names(lcomp_b_pr) <- local({
a <- gsub("^(lcomp.)(.*)(.pr)$","\\2",names(lcomp_b_pr))
b <- gsub("(.*)(.D)$","D.\\1",a) # Convert .D suffix to D. prefix
c <- gsub("^([cr])(.*)","L.\\1\\2",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
lenprob <- list()
## Build age-length conversion matrix associated with each set of length comps
## (will often be the same for all comps)
for(i in 1:length(lcomp_b_pr)){
avail_len_cv_val <- names(rdat$parm.cons)[grepl("^len.cv",names(rdat$parm.cons))]
if(length(avail_len_cv_val)>1){
message(paste("message: found multiple len.cv.val in rdat:",paste(avail_len_cv_val,collapse=", "),"Currently only using len.cv.val"))
}
len_cv_val_i <- rdat$parm.cons$len.cv.val[8]
len_sd_i <- len*len_cv_val_i
lc_i <- lcomp_b_pr[[i]]
lc_bm_i <- as.numeric(colnames(lc_i))  # bin mid point
lc_bw_i <- median(diff(lc_bm_i)) # bin width
lc_bl_i <- lc_bm_i-lc_bw_i/2  # bin lo (minimum)
lenprob_i <- local({
mat_i <- matrix(NA,nrow=length(ages),ncol=length(lc_bm_i),dimnames = list("age"=ages,"lenbin"=lc_bm_i))
mat_i[,1] <- pnorm((lc_bl_i[2]-len)/len_sd_i)
for(i in 2:(ncol(mat_i)-1)){
mat_i[,i] <- pnorm((lc_bl_i[i+1]-len)/len_sd_i)-pnorm((lc_bl_i[i]-len)/len_sd_i)
}
mat_i[,ncol(mat_i)] <- 1-rowSums(mat_i[,1:(ncol(mat_i)-1)])
mat_i
})
lenprob[[i]] <- lenprob_i
}
names(lenprob) <- names(lcomp_b_pr)
## Recompute predicted age and length comps
# Note: These should be the same or very similar to age and length comps computed by BAM.
#  But these are recomputed for the base years as a check since the computation
#  will be used in the projection years
# acomp_b_pr_2 <-  list()
# for(nm_i in names(acomp_b_pr)){
#   yrs_ac_i <- rownames(acomp_b_pr[[nm_i]])
#   if(grepl("^[LD]",nm_i)){ # If length comps are associated with catch (landings or discards), used numbers from landings
#     n_i <- Cn[[paste0("Cn.",nm_i)]][yrs_ac_i,]
#   }else{
#     n_i <- NU[[nm_i]][yrs_ac_i,] # If not (i.e. it's a fishery independent survey) use numbers associated with the index
#   }
#   P_n_i <- t(apply(n_i,1,function(x){x/sum(x)}))
#   acomp_b_pr_2_i <- t(apply(P_n_i,1,function(x){colSums(x*age_error)}))
#   acomp_b_pr_2[[nm_i]] <- acomp_b_pr_2_i
# }
# lcomp_b_pr_2 <-  list()
# for(nm_i in names(lcomp_b_pr)){
#   yrs_lc_i <- rownames(lcomp_b_pr[[nm_i]])
#   lenprob_i <- lenprob[[nm_i]]
#   if(grepl("^[LD]",nm_i)){ # If length comps are associated with catch (landings or discards), used numbers from landings
#     n_i <- Cn[[paste0("Cn.",nm_i)]][yrs_lc_i,]
#   }else{
#     n_i <- NU[[nm_i]][yrs_lc_i,] # If not (i.e. it's a fishery independent survey) use numbers associated with the index
#   }
#   P_n_i <- t(apply(n_i,1,function(x){x/sum(x)}))
#   lcomp_b_pr_2_i <- t(apply(P_n_i,1,function(x){colSums(x*lenprob_i)}))
#   lcomp_b_pr_2[[nm_i]] <- lcomp_2_i
# }
##
# number of trips in compositions
ntrip <- t.series[paste(yb),grepl("^([la]comp).*(.n)$",names(t.series))]
ntrip[ntrip==-99999] <- NA
names(ntrip) <- local({
a <- gsub("(.n)$","",names(ntrip))
b <- gsub("^([al]comp.)(.*)(.)(D)$","\\1D.\\2",a) # Convert .D suffix to D. prefix
c <- gsub("^([al]comp.)([cr])(.*)","\\1L.\\2\\3",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
# number of fish in compositions
nfish <- t.series[paste(yb),grepl("^([la]comp).*(.nfish)$",names(t.series))]
nfish[nfish==-99999] <- NA
names(nfish) <- local({
a <- gsub("(.nfish)$","",names(nfish))
b <- gsub("^([al]comp.)(.*)(.)(D)$","\\1D.\\2",a) # Convert .D suffix to D. prefix
c <- gsub("^([al]comp.)([cr])(.*)","\\1L.\\2\\3",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
#Initial conditions
#Recruits in yr 1 constrained to S-R curve, or else varies in stochastic runs
if(is.null(N_styr_proj)){N_styr_proj <- tail(rdat$N.age,1)}
N_endyr <- rdat$N.age[paste(endyr),]
if(is.null(S_styr_proj)){
S_styr_proj <- local({
Z_styr_proj <- rdat$Z.age[paste(endyr),]
N_endyr_spn <- N_endyr*exp(-1.0*Z_styr_proj*spawn_time)
sum(N_endyr_spn*reprod)
})
}
if(SR_method=="BH"){
if(is.null(SR_par)){
h <-        rdat$parms$BH.steep
R0 <-       rdat$parms$BH.R0
Phi0 <-     rdat$parms$BH.Phi0
biascorr <- rdat$parms$BH.biascorr
}else{
for(i in 1:length(SR_par)){xi <- SR_par[i]; assign(x=names(xi),value=xi)}
}
SR_par_null <- c("h","R0","Phi0","biascorr")[c(is.null(h),is.null(R0),is.null(Phi0),is.null(biascorr))]
# If not all of the BH SR parameters are found, resort to using the GM method
if(length(SR_par_null)>0){
message(paste("message: BH SR parameters not found:",paste(SR_par_null,collapse=", ")," Using SR_method = GM.\n"))
SR_method <- "GM"
}else{
message("message: all BH SR parameters found. Using SR_method = BH.\n")
}
}else{
message(paste("message: Using SR_method = GM.\n"))
}
if(is.null(M)){
M <- a.series$M
}
# } # end if(!is.null(rdat))
library(bamExtras)
