## lenc
init_obs_lenc_nm <- names(init_b)[grepl("^obs_lenc",names(init_b))]
init_obs_lenc_nm_key <- setNames(names(lcomp),
paste0("obs_lenc_",gsub("^(D.)([A-Za-z]+)","\\2_D",gsub("^L.","",names(lcomp)))))
# for(nm_i in init_obs_lenc_nm){
#   nm2_i <- init_obs_lenc_nm_key[[nm_i]]
#   xbi <- init_b[[nm_i]]
#   x2bi <- lcomp[[nm2_i]]
#   ndigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xbi))))
#   obsi <- apply(x2bi,2,function(x){sprintf(paste0("%.",ndigi,"f"), x)})
#   dimnames(obsi) <- dimnames(x2bi)
#   yrsi <- rownames(obsi)
#   init_p[[nm_i]] <- obsi
#   # update styr, endyr, yrs, and nyr as necessary
#   yrinfoi <- setNames(list(min(yrsi),max(yrsi),yrsi,paste(length(yrsi))),
#                       paste0(c("styr","endyr","yrs","nyr"),gsub("obs","",nm_i))
#   )
#   yrinfoi_nm_is <- names(yrinfoi)[names(yrinfoi)%in%names(init_p)]
#   init_p[yrinfoi_nm_is] <- yrinfoi[yrinfoi_nm_is]
#
#   # update nfish and nsamp as necessary
#   nfish_nm_i <- gsub("obs","nfish",nm_i)
#   nsamp_nm_i <- gsub("obs","nsamp",nm_i)
#   nfishbi <- init_b[[nfish_nm_i]]
#   nsampbi <- init_b[[nsamp_nm_i]]
#   nfishdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nfishbi))))
#   nsampdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nsampbi))))
#   nfish2i <- setNames(sprintf(paste0("%.",nfishdigi,"f"), nfish[,paste0("lcomp.",nm2_i)]),rownames(nfish))
#   nsamp2i <- setNames(sprintf(paste0("%.",nsampdigi,"f"), ntrip[,paste0("lcomp.",nm2_i)]),rownames(ntrip))
#
#
#   init_p[[nfish_nm_i]] <- nfish2i[yrsi]
#   init_p[[nsamp_nm_i]] <- nsamp2i[yrsi]
# }
for(nm_i in init_obs_lenc_nm){
nm2_i <- init_obs_lenc_nm_key[[nm_i]]
xbi <- init_b[[nm_i]]
x2bi <- lcomp[[nm2_i]]
ndigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xbi))))
obsi <- apply(x2bi,2,function(x){sprintf(paste0("%.",ndigi,"f"), x)})
attributes(obsi) <- attributes(x2bi)
yrsi <- rownames(obsi)
init_p[[nm_i]] <- obsi
# update styr, endyr, yrs, and nyr as necessary
yrinfoi <- setNames(list(min(yrsi),max(yrsi),yrsi,paste(length(yrsi))),
paste0(c("styr","endyr","yrs","nyr"),gsub("obs","",nm_i))
)
yrinfoi_nm_is <- names(yrinfoi)[names(yrinfoi)%in%names(init_p)]
init_p[yrinfoi_nm_is] <- yrinfoi[yrinfoi_nm_is]
# update nfish and nsamp as necessary
nfish_nm_i <- gsub("obs","nfish",nm_i)
nsamp_nm_i <- gsub("obs","nsamp",nm_i)
nfishbi <- init_b[[nfish_nm_i]]
nsampbi <- init_b[[nsamp_nm_i]]
nfishpi <- setNames(rep(bamExtras::geomean2(nfishbi[paste(tail(yb,nyb_rcn$comp))]),nyp),paste(yp))
nsamppi <- setNames(rep(bamExtras::geomean2(nsampbi[paste(tail(yb,nyb_rcn$comp))]),nyp),paste(yp))
nfishdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nfishbi))))
nsampdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nsampbi))))
nfishi <- setNames(sprintf(paste0("%.",nfishdigi,"f"),round(as.numeric(c(nfishbi,nfishpi)))),names(c(nfishbi,nfishpi)))
nsampi <- setNames(sprintf(paste0("%.",nsampdigi,"f"),round(as.numeric(c(nsampbi,nsamppi)))),names(c(nsampbi,nsamppi)))
init_p[[nfish_nm_i]] <- nfishi[yrsi]
init_p[[nsamp_nm_i]] <- nsampi[yrsi]
}
bam_p <- bam2r(dat_obj=bam$dat,tpl_obj=bam$tpl,cxx_obj=bam$cxx,init=init_p)
}else{
bam_p <- NULL
} # end if(!is.null(bam2r_args))
# plot stuff
if(plot){
par(mfrow=c(2,2),mar=c(3,3,1,1),mgp=c(1,0.2,0),tck=-0.01)
# N
plot(as.numeric(names(Nsum)),Nsum,type="o")
abline(v=endyr)
# R
plot(as.numeric(names(R)),R,type="o")
abline(v=endyr)
# B
plot(as.numeric(names(Bsum)),Bsum,type="o")
abline(v=endyr)
# Fsum
plot(as.numeric(names(Fsum)),Fsum,type="o")
abline(v=endyr)
# Landings and discards
# Cn.L
p <- ggplot(Cn.L,mapping=aes(x=year,y=Ln))+
geom_area(aes(fill=fleet))+
theme_bw()+
scale_fill_brewer(palette="Spectral")+
stat_summary(fun = sum, geom = "line", size = 1)+
stat_summary(fun = sum, geom = "point", size = 2)+
geom_vline(xintercept = endyr, linetype="dashed", size = 0.3)
p2 <- p + geom_text(aes(x=endyr, label="endyr\n",y=max(Ln)), angle=90)
print(p2)
# Cn.D
p2 <- p %+% Cn.D + aes(y=Dn) +
geom_text(aes(x=endyr, label="endyr\n",y=max(Dn)), angle=90)
print(p2)
# Cw.L
p2 <- p %+% Cw.L + aes(y=Lw) +
geom_text(aes(x=endyr, label="endyr\n",y=max(Lw)), angle=90)
print(p2)
# Cw.D
p2 <- p %+% Cw.D + aes(y=Dw) +
geom_text(aes(x=endyr, label="endyr\n",y=max(Dw)), angle=90)
print(p2)
# cpue
matplot(as.numeric(rownames(U)),U,type="o",xlab="",xlim=c(styr,endyr+nyp),pch=1)
# matpoints(as.numeric(rownames(U_p)),U_p,type="o",pch=1)
legend("topleft",legend=colnames(U),col=1:ncol(U),lty=1:ncol(U),pch=1)
abline(v=endyr)
}
library(ggplot2)
library(tidyr)
mt2klb <- 2.20462              # conversion of metric tons to 1000 lb
if(!is.null(run_bam_args)){
if(!"return_obj"%in%names(run_bam_args)){
run_bam_args <- c(run_bam_args,list(return_obj=c("dat","tpl","cxx","rdat")))
}
run_bam_out <- do.call(run_bam,run_bam_args)
rdat <- run_bam_out$rdat
}
# if(!is.null(rdat)){
styr <- rdat$parms$styr
endyr <- rdat$parms$endyr
yb <- styr:endyr # years of the base model
nyb <- length(yb)
a.series <- rdat$a.series
t.series <- rdat$t.series
sel_age <- rdat$sel.age
yrs_L_b <- paste((endyr-(nyb_rcn$L-1)):endyr) # years of recent landings (i.e. from the base model)
yrs_R_b <- paste((endyr-(nyb_rcn$R-1)):endyr)
R_b <- t.series[yrs_R_b,"recruits"]
R_b_gm <- bamExtras::geomean2(R_b)
# Identify F-at-age for each fleet in endyr
# L = (F/Z)*N*(1-exp(-Z))
# L/(N*(1-exp(-Z))) = F/Z
# L*Z/(N*(1-exp(-Z))) = F
# F = L*Z/(N*(1-exp(-Z)))
Cn <- rdat$CLD.est.mats[names(rdat$CLD.est.mats)[grepl("^(Ln|Dn)((?!total).)*$",names(rdat$CLD.est.mats),perl=TRUE)]]
names(Cn) <- gsub("^([LD])(n)(.*)","Cn.\\1\\3",names(Cn))
Cw <- rdat$CLD.est.mats[names(rdat$CLD.est.mats)[grepl("^(Lw|Dw)((?!total).)*$",names(rdat$CLD.est.mats),perl=TRUE)]]
names(Cw) <- gsub("^([LD])(w)(.*)","Cw.\\1\\3",names(Cw))
C_ts_cv <- t.series[paste(yb),grepl("^cv.[DL]",names(t.series))] # cvs associated with components of the catch (removals) during the base years
Z <- rdat$Z.age[paste(yb),]
N <- rdat$N.age[paste(yb),]
Nmdyr <- rdat$N.age.mdyr[paste(yb),]
R <- N[,1] # Recruits
# Like F_fleet in bam tpl (e.g. F_cHL). Same computation as bam
F_flt <- lapply(Cn,function(x){x*Z/(N*(1-exp(-Z)))}) # Computes a list of F (year,age) for each fleet, which are not in the rdat
# names(F_flt) <- paste("F",gsub("([LD])(n)(.*)","\\1\\3",names(F_flt)),sep=".")
names(F_flt) <- gsub("^Cn","F",names(F_flt))
if(is.null(ages)){ages <- a.series$age}
nages <- length(ages)
len <- rdat$a.series$length
if(is.null(age_error)){age_error <- rdat$age.error$error.mat
if(is.null(age_error)){ # If there is no age error matrix in the rdat, just use an identity matrix
age_error <- diag(length(ages))
dimnames(age_error) <- list("age"=ages,"age"=ages)
}
}
if(is.null(spawn_time)){spawn_time <- rdat$parms$spawn.time}
if(is.null(reprod)){reprod <- a.series$reprod}
if(is.null(styr_proj)){styr_proj <- endyr+1}
yp <- styr_proj:(styr_proj+nyp-1) # years of the projection period
if(is.null(F_cur)){F_cur <- bamExtras::geomean2(t.series[yrs_L_b,"F.full"],na.rm=TRUE)}
if(is.null(F_proj)){F_proj <- rdat$parms$Fmsy}
if(is.null(L_cur)){
is.total.L.klb <- "total.L.klb"%in%names(t.series)
if(!is.total.L.klb){
total.L.name <- names(t.series)[grepl("total.L",names(t.series))][1]
message(paste("message: total.L.klb not found in t.series. L_cur is computed from",total.L.name,"instead\n"))
total.L <- t.series[,total.L.name,drop=FALSE]
}else{
total.L <- t.series[,"total.L.klb",drop=FALSE]
message(paste("message: L_cur is computed from t.series$total.L.klb\n"))
}
L_cur <- mean(total.L[yrs_L_b,])
}
if(is.null(sel_L)){sel_L <- sel_age$sel.v.wgted.L}
if(is.null(sel_D)){
if(!is.null(sel_age$sel.v.wgted.D)){
sel_D <- sel_age$sel.v.wgted.D
}else{
message("message: sel_age$sel.v.wgted.D not found. Assessment may not model discards?\n")
}
}
if(is.null(sel_tot)){sel_tot <- sel_age$sel.v.wgted.tot}
if(is.null(sel_F_flt)){
LD_abb <- gsub(".pr$","",names(t.series)[grepl("^[LD].*.pr$",names(t.series),perl=TRUE)]) # landings abbreviations
LD_abb_ts <- paste0("F.",gsub("^(D.)(.*)","\\2.D",gsub("^L.","",LD_abb)))
Fsum_flt <- t.series[paste(yb),LD_abb_ts] # F time series for each fleet
names(Fsum_flt) <- paste0("F.",LD_abb)
Fsum <- rowSums(Fsum_flt) # Should be equal to t.series$Fsum
# Compute selectivity for each fleet associated with an F value.
# NOTE: Computing selectivities is somewhat more reliable than trying to find
# then in the rdat, in instances when selectivities from one fleet are used
# for multiple fleets (e.g. when the headboat selectivity is used for the MRIP landings)
sel_F_flt <- lapply(names(F_flt),function(x){
a <- pmax(pmin(F_flt[[x]]/Fsum_flt[,x],1),0)
a[is.na(a)] <- 0 # Replace NA with zero (NaN will occur when Fsum_flt values are zero, as in years when fleets do not have any landings)
a
})
names(sel_F_flt) <- gsub("^F.","sel.",names(F_flt))
F_ybgm_flt <- apply(tail(Fsum_flt,nyb_rcn$L),2,bamExtras::geomean2) # geomean F by fleet during the last nyb_rcn years of the base model
F_prop_flt <- F_ybgm_flt/sum(F_ybgm_flt) # Proportion of F attributed to each fleet at the end of the assessment
# This is just F_ybgm_flt multiplied by the selectivity in the endyr of the base model for each fleet
# In the bam tpl, these vectors are named F_end although they are summed by landings (F_end_L), discards (F_end_D), or both (F_end)
F_ybgm_flt_a <- as.data.frame(
lapply(1:length(sel_F_flt),function(i){
nm_x <- names(sel_F_flt)[i]
sel_endyr_x <- sel_F_flt[[nm_x]][paste(endyr),]
F_ybgm_flt_x <- F_ybgm_flt[[gsub("^sel.","F.",nm_x)]]
F_ybgm_flt_x*sel_endyr_x
}
)
)
names(F_ybgm_flt_a) <- names(F_ybgm_flt)
# Sum across fleets (these objects are named as in bam tpl)
F_end_L <- rowSums(F_ybgm_flt_a[grepl("^F.L",names(F_ybgm_flt_a))])
F_end_D <- rowSums(F_ybgm_flt_a[grepl("^F.D",names(F_ybgm_flt_a))])
F_end <- rowSums(as.data.frame(F_ybgm_flt_a))
F_end_apex <- max(F_end)
sel_wgted_tot <- F_end/F_end_apex # Should equal to rdat$sel.age$sel.v.wgted.tot
sel_wgted_L <-   sel_wgted_tot*(F_end_L/F_end) # Should equal rdat$sel.age$sel.v.wgted.L # F_end_L/F_end_apex # as in tpl
sel_wgted_D <-   sel_wgted_tot*(F_end_D/F_end) # Should equal rdat$sel.age$sel.v.wgted.D # F_end_D/F_end_apex # as in tpl
sel_wgted_F_flt <- F_ybgm_flt_a/F_end_apex     # by extension, scale selectivity at age for each fleet
# Note that: round((sel_wgted_L+sel_wgted_D) == rowSums(sel_wgted_F_flt)
}
## Weights of fish (year, age)
if(is.null(wgt_mt)){wgt_mt <- a.series$wgt.mt}
wgt_klb <- wgt_mt*mt2klb
wgt_b_klb <- matrix(wgt_klb,nrow=nyb,ncol=nages,byrow=TRUE,dimnames=list(yb,ages))
if(is.null(wgt_L_klb)){
wgt.wgted.L.klb_nm <- names(a.series)[grepl("^[A-Za-z]*wgt.wgted.L.klb",names(a.series))]
if(length(wgt.wgted.L.klb_nm)>0){
message(paste0("message: ", wgt.wgted.L.klb_nm, " found in names(a.series) and used to set wgt_L_klb\n"))
wgt_L_klb <- a.series[,wgt.wgted.L.klb_nm[1]]
}else{
warning("message: no wgt.wgted.L.klb found in names(a.series).\n")
}
}
if(is.null(wgt_D_klb)){
wgt.wgted.D.klb_nm <- names(a.series)[grepl("^[A-Za-z]*wgt.wgted.D.klb",names(a.series))]
if(length(wgt.wgted.D.klb_nm)>0){
message(paste0("message: ", wgt.wgted.D.klb_nm, " found in names(a.series) and used to set wgt_D_klb\n"))
wgt_D_klb <- a.series[,wgt.wgted.D.klb_nm[1]]
}else{
warning("message: no wgt.wgted.D.klb found in names(a.series). Does this assessment model discards?\n")
}
}
## Weights of fish (year, age) by fleet.
if(is.null(wgt_F_flt_klb)){
wgt_F_flt_klb <- rdat$size.age.fishery[grepl("^[a-zA_Z]*.*wgt",names(rdat$size.age.fishery))]
# Reformat names to wgt.fleetType.fleet
# (e.g. wgt.L.cHL for weight of landings in the commercial hook and line fleet)
wgt_F_flt_abb <- local({
a <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\3",names(wgt_F_flt_klb),perl=TRUE)
gsub("^([^D.])([a-zA-Z]+)","L.\\1\\2",gsub("(.*?)(?<=.)(.D)$","D.\\1",a,perl=TRUE))
})
wgt_F_flt_units <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\1.\\5",names(wgt_F_flt_klb),perl=TRUE)
names(wgt_F_flt_klb) <- names(wgt_F_flt_units) <- paste("wgt", #wgt_F_flt_units,
wgt_F_flt_abb,sep=".")
# Convert weights in lb to klb
for(nm_i in names(wgt_F_flt_klb)){
xi <- wgt_F_flt_klb[[nm_i]]
if(grepl("\\.lb$",wgt_F_flt_units[[nm_i]])){
wgt_F_flt_klb[[nm_i]] <- xi/1000
wgt_F_flt_units[[nm_i]] <- gsub(".lb$",".klb",wgt_F_flt_units[[nm_i]])
}
}
}
# Lengths of fish (year, age) by fleet.
if(is.null(len_F_flt_mm)){
len_F_flt_mm <- rdat$size.age.fishery[grepl("^[a-zA_Z]*.*len",names(rdat$size.age.fishery))]
# Reformat names to len.fleetType.fleet
# (e.g. len.L.cHL for length of landings in the commercial hook and line fleet)
len_F_flt_abb <- local({
a <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\3",names(len_F_flt_mm),perl=TRUE)
gsub("^([^D.])([a-zA-Z]+)","L.\\1\\2",gsub("(.*?)(?<=.)(.D)$","D.\\1",a,perl=TRUE))
})
len_F_flt_units <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\1.\\5",names(len_F_flt_mm),perl=TRUE)
names(len_F_flt_mm) <- names(len_F_flt_units) <- paste("len", #len_F_flt_units,
len_F_flt_abb,sep=".")
}
# Recompute landings by fleet to compare with calculations used in projections
Cn2 <- lapply(Cn,function(x){x*NA})
Cw2 <- lapply(Cw,function(x){x*NA})
for(i in 1:length(yb)){
for(j in 1:ncol(Fsum_flt)){
Cn2[[j]][i,] <- L_calc(F_flt[[j]][i,], Z[i,], N[i,])
Cw2[[j]][i,] <- L_calc(F_flt[[j]][i,], Z[i,], N[i,], wgt_F_flt_klb[[j]][i])
}
}
# CPUE
#   From bam tpl for SEDAR53:
#     N_cHL(iyear)=elem_prod(elem_prod(Nmdyr(iyear),sel_cHL(iyear)),wholewgt_cHL_klb(iyear));
#     pred_cHL_cpue(iyear)=q_cHL(iyear)*q_rate_fcn_cHL(iyear)*q_DD_fcn(iyear)*sum(N_cHL(iyear));
U_a <- list()
NU <- list()
unit_U <- list()
U_ts_pr <- t.series[paste(yb),grepl("^U.*pr$",names(t.series)),drop=FALSE]
U_ts_ob <- t.series[paste(yb),grepl("^U.*ob$",names(t.series)),drop=FALSE]
U_ts_cv <- t.series[paste(yb),grepl("^cv.U",names(t.series)),drop=FALSE] # cvs associated with U during the base years
# names(U_ts_pr) <- gsub("^(U.)(.*)(.)(pr)$","\\1\\4.\\2",names(U_ts_pr))
U_abb <- gsub("^U.|.pr$","",names(U_ts_pr))
names(U_ts_pr) <- names(U_ts_ob) <- U_abb
# Find q values in rdat
# Are the q values provided in t.series?
q_nm <- paste0("q.",U_abb)
q_nm_tsY <- q_nm[q_nm%in%names(t.series)]
q_nm_tsN <- q_nm[!q_nm%in%names(t.series)]
q_nm_tsNpcY <- paste0("log.",q_nm_tsN)[paste0("log.",q_nm_tsN)%in%names(rdat$parm.cons)]
q_nm_tsNpcN <- q_nm[which((!q_nm%in%names(t.series))&(!paste0("log.",q_nm)%in%names(rdat$parm.cons)))]
if(length(q_nm_tsY)>0){
q_mn <- t.series[paste(yb),q_nm_tsY,drop=FALSE]  # This is really a kind of mean q, since q_rate and q_DD_mult might scale it to compute U
}
# If any of the q values are not in t.series, look in parms.cons
if(length(q_nm_tsN)>0){
message(paste0("message: ",paste(q_nm_tsN,collapse=", "), " not found in t.series"))
if(length(q_nm_tsNpcY)>0){
message(paste0("message: time invariant values of",paste(q_nm_tsNpcY,collapse=", "), " found in parm.cons will be used instead."))
q_tsNpcY <- exp(rdat$parm.cons[q_nm_tsNpcY][8,])
names(q_tsNpcY) <- gsub("^log.q.","",names(q_tsNpcY))
for(nm_i in names(q_tsNpcY)){
a <- U_ts_pr[,nm_i]
a[!is.na(a)] <- q_tsNpcY[[nm_i]]
q_mn[,paste0("q.",nm_i)] <- a
}
}
}
# If any q not in t.series or parm.cons
if(length(q_nm_tsNpcN)>0){
warning(paste0(paste(q_nm_tsNpcN,collapse=", "), " not found in t.series or parm.cons. Can't compute these cpue indices in the projections."))
}
q_DD_mult <- t.series[paste(yb),"q.DD.mult",drop=FALSE] # density dependent function as a multiple of q (scaled a la Katsukawa and Matsuda. 2003)
q_rate <- q_mn*0+1
q <- q_mn*NA # Initialize values for final q value (q_mn * q_rate * q_DD_mult) multiplied by N to compute CPUE
sel_U <- sel_age[which(gsub("sel.[vm].|(wgted.)","",names(sel_age))%in%U_abb)]
names(sel_U) <- U_abb
for(i in 1:length(sel_U)){
if(is.vector(sel_U[[i]])){
sel_U[[i]] <- matrix(sel_U[[i]], nrow=length(yb),ncol=length(sel_U[[i]]),byrow=TRUE,dimnames=list(yb,names(sel_U[[i]])))
}
sel_U_i <- sel_U[[i]]
sel_nm_i <- names(sel_U)[i]
sel_abb_i <- gsub("sel.[vm].","",sel_nm_i)
q_nm_i <- paste0("q.",sel_abb_i)
q_mn_i <- q_mn[paste(yb),q_nm_i,drop=FALSE]
q_rate_nm_i <- paste0("q.",sel_abb_i,".rate.mult")
if(q_rate_nm_i%in%names(t.series)){
q_rate_i <- t.series[paste(yb),q_rate_nm_i,drop=FALSE]
}else{
q_rate_i <- q_mn_i*0+1
message(paste("message:",q_rate_nm_i,"not found in t.series. Setting q rate multiplier values to 1.\n"))
}
q_rate[,q_nm_i] <- q_rate_i
q_i <- q_mn_i*q_rate_i*q_DD_mult
q[,q_nm_i] <- q_i
unit_U_n_i <- local({ # Set default unit = 1 for keeping the index in numbers
a <- sel_U_i
a*0+1
})
# Since it can be hard to know if the index was in units of weight or numbers
# which affects q, compute it both ways and then see which matches the
# values in the base model better, then change the appropriate values.
# If the U type is commercial or recreational (not a fishery independent survey), get unit_U_w_i from wgt_F_flt_klb..
# WARNING: IN SOME CASES OF DISCARD INDICES THIS SHOULD BE LOOKING FOR WEIGHTS IN wgt.D!!! CODE IT NIKOLAI!!
if(gsub("^(.{1})(.*)","\\1",sel_abb_i)%in%c("r","c")){
unit_U_nm_i <- paste0("wgt.L.",sel_abb_i)
if(unit_U_nm_i%in%names(wgt_F_flt_klb)){
unit_U_w_i <- wgt_F_flt_klb[[paste0("wgt.L.",sel_abb_i)]]
}else{
message(paste("message: I could not find",unit_U_nm_i, "to multiply by", sel_nm_i,"when computing", paste0("N_",sel_abb_i,"."), paste0("U_pr_",sel_abb_i), "will be computed in numbers instead of weight.\n"))
}
}else{
# ..otherwise use population weights
unit_U_w_i <- wgt_b_klb
}
NUn_i <- Nmdyr*sel_U_i*unit_U_n_i
NUw_i <- Nmdyr*sel_U_i*unit_U_w_i
# U_a_i <- unlist(q_i)*NU_i
U_a_n_i <- unlist(q_i)*NUn_i
U_a_w_i <- unlist(q_i)*NUw_i
U_n_i <- rowSums(U_a_n_i)
U_w_i <- rowSums(U_a_w_i)
U_ts_ob_i <- U_ts_ob[,sel_abb_i]
U_ts_pr_i <- U_ts_pr[,sel_abb_i]
# Compute the sums of squared deviations to determine whether the indices are
# in numbers or in weight. Indices in the appropriate units are then added
# to the the appropriate objects
SSUi <- unlist(lapply(list(U_n_i=U_n_i,U_w_i=U_w_i),function(x){sum((U_ts_pr_i-x)^2,na.rm=TRUE)}))
if(names(SSUi)[which.min(SSUi)]=="U_n_i"){
message(paste("message: The",sel_abb_i,"index appears to be in numbers in the base years and will therefore be projected in numbers."))
NU_i <- NUn_i
U_a_i <- U_a_n_i
unit_U_i <- unit_U_n_i
}else{
message(paste("message: The",sel_abb_i,"index appears to be in weight in the base years and will therefore be projected in weight."))
NU_i <- NUw_i
U_a_i <- U_a_w_i
unit_U_i <- unit_U_w_i
}
ndigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",na.omit(U_ts_ob_i)))))
xpi <- round(get(names(SSUi)[which.min(SSUi)]),ndigi)
NU[[i]] <- NU_i
U_a[[i]] <- U_a_i
unit_U[[i]] <- unit_U_i
}
names(U_a) <- names(unit_U) <- names(NU) <- U_abb
U <- as.data.frame(lapply(U_a,rowSums))
## age compositions from the base years
# observed
acomp_b_ob <- rdat$comp.mats[grepl("^acomp.*.ob$",names(rdat$comp.mats))]
names(acomp_b_ob) <- local({
a <- gsub("^(acomp.)(.*)(.ob)$","\\2",names(acomp_b_ob))
b <- gsub("(.*)(.D)$","D.\\1",a) # Convert .D suffix to D. prefix
c <- gsub("^([cr])(.*)","L.\\1\\2",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
# predicted
acomp_b_pr <- rdat$comp.mats[grepl("^acomp.*.pr$",names(rdat$comp.mats))]
names(acomp_b_pr) <- local({
a <- gsub("^(acomp.)(.*)(.pr)$","\\2",names(acomp_b_pr))
b <- gsub("(.*)(.D)$","D.\\1",a) # Convert .D suffix to D. prefix
c <- gsub("^([cr])(.*)","L.\\1\\2",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
## length compositions from the base years
# observed
lcomp_b_ob <- rdat$comp.mats[grepl("^lcomp.*.ob$",names(rdat$comp.mats))]
names(lcomp_b_ob) <- local({
a <- gsub("^(lcomp.)(.*)(.ob)$","\\2",names(lcomp_b_ob))
b <- gsub("(.*)(.D)$","D.\\1",a) # Convert .D suffix to D. prefix
c <- gsub("^([cr])(.*)","L.\\1\\2",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
# predicted
lcomp_b_pr <- rdat$comp.mats[grepl("^lcomp.*.pr$",names(rdat$comp.mats))]
names(lcomp_b_pr) <- local({
a <- gsub("^(lcomp.)(.*)(.pr)$","\\2",names(lcomp_b_pr))
b <- gsub("(.*)(.D)$","D.\\1",a) # Convert .D suffix to D. prefix
c <- gsub("^([cr])(.*)","L.\\1\\2",b) # Add L. prefix to comps starting with c or r (landings not discards. won't modify fishery independent survey comps)
c
})
lenprob <- list()
lcomp_b_pr
for(i in 1:length(lcomp_b_pr)){
avail_len_cv_val <- names(rdat$parm.cons)[grepl("^len.cv",names(rdat$parm.cons))]
if(length(avail_len_cv_val)>1){
message(paste("message: found multiple len.cv.val in rdat:",paste(avail_len_cv_val,collapse=", "),"Currently only using len.cv.val"))
}
len_cv_val_i <- rdat$parm.cons$len.cv.val[8]
len_sd_i <- len*len_cv_val_i
lc_i <- lcomp_b_pr[[i]]
lc_bm_i <- as.numeric(colnames(lc_i))  # bin mid point
lc_bw_i <- median(diff(lc_bm_i)) # bin width
lc_bl_i <- lc_bm_i-lc_bw_i/2  # bin lo (minimum)
lenprob_i <- local({
mat_i <- matrix(NA,nrow=length(ages),ncol=length(lc_bm_i),dimnames = list("age"=ages,"lenbin"=lc_bm_i))
mat_i[,1] <- pnorm((lc_bl_i[2]-len)/len_sd_i)
for(i in 2:(ncol(mat_i)-1)){
mat_i[,i] <- pnorm((lc_bl_i[i+1]-len)/len_sd_i)-pnorm((lc_bl_i[i]-len)/len_sd_i)
}
mat_i[,ncol(mat_i)] <- 1-rowSums(mat_i[,1:(ncol(mat_i)-1)])
mat_i
})
lenprob[[i]] <- lenprob_i
}
i
avail_len_cv_val <- names(rdat$parm.cons)[grepl("^len.cv",names(rdat$parm.cons))]
if(length(avail_len_cv_val)>1){
message(paste("message: found multiple len.cv.val in rdat:",paste(avail_len_cv_val,collapse=", "),"Currently only using len.cv.val"))
}
avail_len_cv_val
len_cv_val_i <- rdat$parm.cons$len.cv.val[8]
len_sd_i <- len*len_cv_val_i
lc_i <- lcomp_b_pr[[i]]
lc_bm_i <- as.numeric(colnames(lc_i))  # bin mid point
lc_bw_i <- median(diff(lc_bm_i)) # bin width
lc_bl_i <- lc_bm_i-lc_bw_i/2  # bin lo (minimum)
mat_i <- matrix(NA,nrow=length(ages),ncol=length(lc_bm_i),dimnames = list("age"=ages,"lenbin"=lc_bm_i))
mat_i[,1] <- pnorm((lc_bl_i[2]-len)/len_sd_i)
for(i in 2:(ncol(mat_i)-1)){
mat_i[,i] <- pnorm((lc_bl_i[i+1]-len)/len_sd_i)-pnorm((lc_bl_i[i]-len)/len_sd_i)
}
mat_i[,ncol(mat_i)] <- 1-rowSums(mat_i[,1:(ncol(mat_i)-1)])
mat_i
lc_bl_i
pnorm((lc_bl_i[2]-len)/len_sd_i)
len
len_sd_i
len_cv_val_i
rdat$parm.cons$len_cv_val
i
i <- 1
avail_len_cv_val <- names(rdat$parm.cons)[grepl("^len.cv",names(rdat$parm.cons))]
if(length(avail_len_cv_val)>1){
message(paste("message: found multiple len.cv.val in rdat:",paste(avail_len_cv_val,collapse=", "),"Currently only using len.cv.val"))
}
len_cv_val_i <- rdat$parm.cons$len.cv.val[8]
len_sd_i <- len*len_cv_val_i
lc_i <- lcomp_b_pr[[i]]
lc_bm_i <- as.numeric(colnames(lc_i))  # bin mid point
lc_bw_i <- median(diff(lc_bm_i)) # bin width
lc_bl_i <- lc_bm_i-lc_bw_i/2  # bin lo (minimum)
lc_bl_i
mat_i <- matrix(NA,nrow=length(ages),ncol=length(lc_bm_i),dimnames = list("age"=ages,"lenbin"=lc_bm_i))
mat_i[,1] <- pnorm((lc_bl_i[2]-len)/len_sd_i)
len_sd_i
rdat$parm.cons$len.cv.val
View(standardize_bam)
library(bamExtras)
