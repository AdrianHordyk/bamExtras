nfishbi <- init_b[[nfish_nm_i]]
nsampbi <- init_b[[nsamp_nm_i]]
nfishpi <- setNames(rep(bamExtras::geomean2(nfishbi[paste(tail(yb,nyb_rcn$comp))]),nyp),paste(yp))
nsamppi <- setNames(rep(bamExtras::geomean2(nsampbi[paste(tail(yb,nyb_rcn$comp))]),nyp),paste(yp))
nfishdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nfishbi))))
nsampdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nsampbi))))
nfishi <- setNames(sprintf(paste0("%.",nfishdigi,"f"),round(as.numeric(c(nfishbi,nfishpi)))),names(c(nfishbi,nfishpi)))
nsampi <- setNames(sprintf(paste0("%.",nsampdigi,"f"),round(as.numeric(c(nsampbi,nsamppi)))),names(c(nsampbi,nsamppi)))
init_p[[nfish_nm_i]] <- nfishi[yrsi]
init_p[[nsamp_nm_i]] <- nsampi[yrsi]
}
bam_p <- bam2r(dat_obj=bam$dat,tpl_obj=bam$tpl,cxx_obj=bam$cxx,init=init_p)
}else{
bam_p <- NULL
} # end if(!is.null(bam2r_args))
# plot stuff
if(plot){
par(mfrow=c(2,2),mar=c(3,3,1,1),mgp=c(1,0.2,0),tck=-0.01)
# N
plot(as.numeric(names(Nsum)),Nsum,type="o")
abline(v=endyr)
# R
plot(as.numeric(names(R)),R,type="o")
abline(v=endyr)
# B
plot(as.numeric(names(Bsum)),Bsum,type="o")
abline(v=endyr)
# Fsum
plot(as.numeric(names(Fsum)),Fsum,type="o")
abline(v=endyr)
# Landings and discards
# Cn.L
p <- ggplot(Cn.L,mapping=aes(x=year,y=Ln))+
geom_area(aes(fill=fleet))+
theme_bw()+
scale_fill_brewer(palette="Spectral")+
stat_summary(fun = sum, geom = "line", size = 1)+
stat_summary(fun = sum, geom = "point", size = 2)+
geom_vline(xintercept = endyr, linetype="dashed", size = 0.3)
p2 <- p + geom_text(aes(x=endyr, label="endyr\n",y=max(Ln)), angle=90)
print(p2)
# Cn.D
if(nrow(Cn.D)>0){
p2 <- p %+% Cn.D + aes(y=Dn) +
geom_text(aes(x=endyr, label="endyr\n",y=max(Dn)), angle=90)
print(p2)
}
# Cw.L
p2 <- p %+% Cw.L + aes(y=Lw) +
geom_text(aes(x=endyr, label="endyr\n",y=max(Lw)), angle=90)
print(p2)
# Cw.D
if(nrow(Cw.D)>0){
p2 <- p %+% Cw.D + aes(y=Dw) +
geom_text(aes(x=endyr, label="endyr\n",y=max(Dw)), angle=90)
print(p2)
}
# cpue
matplot(as.numeric(rownames(U)),U,type="o",xlab="",xlim=c(styr,endyr+nyp),pch=1)
# matpoints(as.numeric(rownames(U_p)),U_p,type="o",pch=1)
legend("topleft",legend=colnames(U),col=1:ncol(U),lty=1:ncol(U),pch=1)
abline(v=endyr)
}
library(bamExtras)
setwd("~/GitHub/myPackages/bamExtras/TEST_FOLDER/run_proj")
library(bamExtras)
rm(list=ls())
testFun <- function(CommonName,
lastYear = as.numeric(format(Sys.Date(),"%Y"))-1,
run_proj_args = list()){
dir_base <- file.path(CommonName,"figs-base")
dir_update <- file.path(CommonName,"figs-update")
rdat <- get(paste0("rdat_",CommonName))
dat <-  get(paste0("dat_",CommonName))
tpl <-  get(paste0("tpl_",CommonName))
cxx <-  get(paste0("cxx_",CommonName))
plot_bam(rdat)
########## Copy data files to folder
if(!dir.exists(dir_base)){
dir.create(dir_base,recursive = TRUE)
}
file.copy(from=file.path("spp-figs",list.files("spp-figs")),
to=dir_base,recursive = TRUE)
unlink("spp-figs", recursive=T)
bam_proj <- do.call(run_proj,c(run_proj_args,list(rdat = rdat,
bam2r_args = list(dat_obj=dat,tpl_obj=tpl,cxx_obj=cxx),
nyp = length((rdat$parms$endyr+1):lastYear),
plot=TRUE)))
message("run_proj ran successfully")
bam_update <- run_bam(bam=bam_proj$bam_p,unlink_dir_bam = FALSE)
# Plot bam update results
plot_bam(bam_update$rdat)
########## Copy data files to folder
if(!dir.exists(dir_update)){
dir.create(dir_update,recursive=TRUE)
}
file.copy(from=file.path("spp-figs",list.files("spp-figs")),
to=dir_update,recursive = TRUE)
unlink("spp-figs", recursive=T)
}
## Run tests
# # these work!
testFun("BlackSeaBass")
testFun("GagGrouper")
testFun("GrayTriggerfish",run_proj_args = list(F_proj=rdat_GrayTriggerfish$parms$F30))
testFun("RedGrouper")
testFun("RedPorgy")
testFun("RedSnapper",run_proj_args = list(F_proj=rdat_RedSnapper$parms$F30))
testFun("Tilefish")
testFun("VermilionSnapper",run_proj_args = list(F_proj=rdat_VermilionSnapper$parms$Fmsy*0.75))
# These generate errors
# testFun("AtlanticMenhaden") # errors
# testFun("BluelineTilefish") # errors
# testFun("Cobia") # errors
# testFun("GreaterAmberjack") # errors
testFun("ScampGrouper") # errors
# These generate errors
# testFun("AtlanticMenhaden") # errors
# testFun("BluelineTilefish") # errors
# testFun("Cobia") # errors
# testFun("GreaterAmberjack") # errors
testFun("SnowyGrouper") # errors
# These generate errors
# testFun("AtlanticMenhaden") # errors
# testFun("BluelineTilefish") # errors
# testFun("Cobia") # errors
testFun("GreaterAmberjack") # errors
# These generate errors
# testFun("AtlanticMenhaden") # errors
# testFun("BluelineTilefish") # errors
testFun("Cobia") # errors
# These generate errors
# testFun("AtlanticMenhaden") # errors
testFun("BluelineTilefish") # errors
# These generate errors
# testFun("AtlanticMenhaden") # errors
#testFun("BluelineTilefish") # errors
#testFun("GreaterAmberjack") # errors
testFun("SpanishMackerel") # errors
source("~/GitHub/myPackages/bamExtras/TEST_FOLDER/run_proj/run_proj_test_args.r", echo=TRUE)
library(ggplot2)
library(tidyr)
mt2klb <- 2.20462              # conversion of metric tons to 1000 lb
if(!is.null(run_bam_args)){
if(!"return_obj"%in%names(run_bam_args)){
run_bam_args <- c(run_bam_args,list(return_obj=c("dat","tpl","cxx","rdat")))
}
run_bam_out <- do.call(run_bam,run_bam_args)
rdat <- run_bam_out$rdat
}
# if(!is.null(rdat)){
styr <- rdat$parms$styr
endyr <- rdat$parms$endyr
yb <- styr:endyr # years of the base model
nyb <- length(yb)
a.series <- rdat$a.series
t.series <- rdat$t.series
t.series[t.series==-99999] <- NA
parm.cons <- rdat$parm.cons
sel_age <- rdat$sel.age
sel_age_1 <- sel_age[names(sel_age)%in%c("sel.v.wgted.L","sel.v.wgted.D","sel.v.wgted.tot")]
sel_age_2 <- sel_age[!names(sel_age)%in%names(sel_age_1)]
yrs_L_b <- paste((endyr-(nyb_rcn$L-1)):endyr) # years of recent landings (i.e. from the base model)
yrs_R_b <- paste((endyr-(nyb_rcn$R-1)):endyr)
R_b <- t.series[yrs_R_b,"recruits"]
R_b_gm <- bamExtras::geomean2(R_b)
# Identify F-at-age for each fleet in endyr
# L = (F/Z)*N*(1-exp(-Z))
# L/(N*(1-exp(-Z))) = F/Z
# L*Z/(N*(1-exp(-Z))) = F
# F = L*Z/(N*(1-exp(-Z)))
Cn <- rdat$CLD.est.mats[names(rdat$CLD.est.mats)[grepl("^(Ln|Dn)((?!total).)*$",names(rdat$CLD.est.mats),perl=TRUE)]]
names(Cn) <- gsub("^([LD])(n)(.*)","Cn.\\1\\3",names(Cn))
Cw <- rdat$CLD.est.mats[names(rdat$CLD.est.mats)[grepl("^(Lw|Dw)((?!total).)*$",names(rdat$CLD.est.mats),perl=TRUE)]]
names(Cw) <- gsub("^([LD])(w)(.*)","Cw.\\1\\3",names(Cw))
C_ts_cv <- t.series[paste(yb),grepl("^cv.[DL]",names(t.series))] # cvs associated with components of the catch (removals) during the base years
Z <- rdat$Z.age[paste(yb),]
N <- rdat$N.age[paste(yb),]
Nmdyr <- rdat$N.age.mdyr[paste(yb),]
R <- N[,1] # Recruits
# Like F_fleet in bam tpl (e.g. F_cHL). Same computation as bam
F_flt <- lapply(Cn,function(x){x*Z/(N*(1-exp(-Z)))}) # Computes a list of F (year,age) for each fleet, which are not in the rdat
# names(F_flt) <- paste("F",gsub("([LD])(n)(.*)","\\1\\3",names(F_flt)),sep=".")
names(F_flt) <- gsub("^Cn","F",names(F_flt))
if(is.null(ages)){ages <- a.series$age}
nages <- length(ages)
len <- rdat$a.series$length
if(is.null(age_error)){age_error <- rdat$age.error$error.mat
if(is.null(age_error)){ # If there is no age error matrix in the rdat, just use an identity matrix
age_error <- diag(length(ages))
dimnames(age_error) <- list("age"=ages,"age"=ages)
}
}
if(is.null(spawn_time)){spawn_time <- rdat$parms$spawn.time}
if(is.null(reprod)){reprod <- a.series$reprod}
if(is.null(styr_proj)){styr_proj <- endyr+1}
yp <- styr_proj:(styr_proj+nyp-1) # years of the projection period
if(is.null(F_cur)){F_cur <- bamExtras::geomean2(t.series[yrs_L_b,"F.full"],na.rm=TRUE)}
if(is.null(F_proj)){F_proj <- rdat$parms$Fmsy}
if(is.null(L_cur)){
is.total.L.klb <- "total.L.klb"%in%names(t.series)
if(!is.total.L.klb){
total.L.name <- names(t.series)[grepl("total.L",names(t.series))][1]
message(paste("total.L.klb not found in t.series. L_cur is computed from",total.L.name,"instead\n"))
total.L <- t.series[,total.L.name,drop=FALSE]
}else{
total.L <- t.series[,"total.L.klb",drop=FALSE]
message(paste("L_cur is computed from t.series$total.L.klb\n"))
}
L_cur <- mean(total.L[yrs_L_b,])
}
if(is.null(sel_L)){sel_L <- sel_age_1$sel.v.wgted.L}
if(is.null(sel_D)){
if(!is.null(sel_age_1$sel.v.wgted.D)){
sel_D <- sel_age_1$sel.v.wgted.D
}else{
message("sel_age_1$sel.v.wgted.D not found. Assessment may not model discards?\n")
}
}
if(is.null(sel_tot)){sel_tot <- sel_age_1$sel.v.wgted.tot}
if(is.null(sel_F_flt)){
LD_abb <- gsub(".pr$","",names(t.series)[grepl("^[LD].*.pr$",names(t.series),perl=TRUE)]) # landings abbreviations
LD_abb_ts <- paste0("F.",gsub("^(D.)(.*)","\\2.D",gsub("^L.","",LD_abb)))
Fsum_flt <- t.series[paste(yb),LD_abb_ts] # F time series for each fleet
names(Fsum_flt) <- paste0("F.",LD_abb)
Fsum <- rowSums(Fsum_flt) # Should be equal to t.series$Fsum
# Compute selectivity for each fleet associated with an F value.
# NOTE: Computing selectivities is somewhat more reliable than trying to find
# then in the rdat, in instances when selectivities from one fleet are used
# for multiple fleets (e.g. when the headboat selectivity is used for the MRIP landings)
sel_F_flt <- lapply(names(F_flt),function(x){
a <- pmax(pmin(F_flt[[x]]/Fsum_flt[,x],1),0)
a[is.na(a)] <- 0 # Replace NA with zero (NaN will occur when Fsum_flt values are zero, as in years when fleets do not have any landings)
a
})
names(sel_F_flt) <- gsub("^F.","sel.",names(F_flt))
F_ybgm_flt <- apply(tail(Fsum_flt,nyb_rcn$L),2,bamExtras::geomean2) # geomean F by fleet during the last nyb_rcn years of the base model
F_prop_flt <- F_ybgm_flt/sum(F_ybgm_flt) # Proportion of F attributed to each fleet at the end of the assessment
# This is just F_ybgm_flt multiplied by the selectivity in the endyr of the base model for each fleet
# In the bam tpl, these vectors are named F_end although they are summed by landings (F_end_L), discards (F_end_D), or both (F_end)
F_ybgm_flt_a <- as.data.frame(
lapply(1:length(sel_F_flt),function(i){
nm_x <- names(sel_F_flt)[i]
sel_endyr_x <- sel_F_flt[[nm_x]][paste(endyr),]
F_ybgm_flt_x <- F_ybgm_flt[[gsub("^sel.","F.",nm_x)]]
F_ybgm_flt_x*sel_endyr_x
}
)
)
names(F_ybgm_flt_a) <- names(F_ybgm_flt)
# Sum across fleets (these objects are named as in bam tpl)
F_end_L <- rowSums(F_ybgm_flt_a[grepl("^F.L",names(F_ybgm_flt_a))])
F_end_D <- rowSums(F_ybgm_flt_a[grepl("^F.D",names(F_ybgm_flt_a))])
F_end <- rowSums(as.data.frame(F_ybgm_flt_a))
F_end_apex <- max(F_end)
sel_wgted_tot <- F_end/F_end_apex # Should equal to rdat$sel.age$sel.v.wgted.tot
sel_wgted_L <-   sel_wgted_tot*(F_end_L/F_end) # Should equal rdat$sel.age$sel.v.wgted.L # F_end_L/F_end_apex # as in tpl
sel_wgted_D <-   sel_wgted_tot*(F_end_D/F_end) # Should equal rdat$sel.age$sel.v.wgted.D # F_end_D/F_end_apex # as in tpl
sel_wgted_F_flt <- F_ybgm_flt_a/F_end_apex     # by extension, scale selectivity at age for each fleet
# Note that: round((sel_wgted_L+sel_wgted_D) == rowSums(sel_wgted_F_flt)
}
## Weights of fish (year, age)
if(is.null(wgt_mt)){wgt_mt <- a.series$wgt.mt}
wgt_klb <- wgt_mt*mt2klb
wgt_b_klb <- matrix(wgt_klb,nrow=nyb,ncol=nages,byrow=TRUE,dimnames=list(yb,ages))
if(is.null(wgt_L_klb)){
wgt.wgted.L.klb_nm <- names(a.series)[grepl("^[A-Za-z]*wgt.wgted.L.klb",names(a.series))]
if(length(wgt.wgted.L.klb_nm)>0){
message(paste0(wgt.wgted.L.klb_nm, " found in names(a.series) and used to set wgt_L_klb\n"))
wgt_L_klb <- a.series[,wgt.wgted.L.klb_nm[1]]
}else{
warning("no wgt.wgted.L.klb found in names(a.series).\n")
}
}
if(is.null(wgt_D_klb)){
wgt.wgted.D.klb_nm <- names(a.series)[grepl("^[A-Za-z]*wgt.wgted.D.klb",names(a.series))]
if(length(wgt.wgted.D.klb_nm)>0){
message(paste0(wgt.wgted.D.klb_nm, " found in names(a.series) and used to set wgt_D_klb\n"))
wgt_D_klb <- a.series[,wgt.wgted.D.klb_nm[1]]
}else{
warning("no wgt.wgted.D.klb found in names(a.series). Does this assessment model discards?\n")
}
}
## Weights of fish (year, age) by fleet.
if(is.null(wgt_F_flt_klb)){
wgt_F_flt_klb <- rdat$size.age.fishery[grepl("^[a-zA_Z]*.*wgt",names(rdat$size.age.fishery))]
# Reformat names to wgt.fleetType.fleet
# (e.g. wgt.L.cHL for weight of landings in the commercial hook and line fleet)
wgt_F_flt_abb <- local({
a <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\3",names(wgt_F_flt_klb),perl=TRUE)
gsub("^([^D.])([a-zA-Z]+)","L.\\1\\2",gsub("(.*?)(?<=.)(.D)$","D.\\1",a,perl=TRUE))
})
wgt_F_flt_units <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\1.\\5",names(wgt_F_flt_klb),perl=TRUE)
names(wgt_F_flt_klb) <- names(wgt_F_flt_units) <- paste("wgt", #wgt_F_flt_units,
wgt_F_flt_abb,sep=".")
# Convert weights in lb to klb
for(nm_i in names(wgt_F_flt_klb)){
xi <- wgt_F_flt_klb[[nm_i]]
if(grepl("\\.lb$",wgt_F_flt_units[[nm_i]])){
wgt_F_flt_klb[[nm_i]] <- xi/1000
wgt_F_flt_units[[nm_i]] <- gsub(".lb$",".klb",wgt_F_flt_units[[nm_i]])
}
}
}
# Lengths of fish (year, age) by fleet.
if(is.null(len_F_flt_mm)){
len_F_flt_mm <- rdat$size.age.fishery[grepl("^[a-zA_Z]*.*len",names(rdat$size.age.fishery))]
# Reformat names to len.fleetType.fleet
# (e.g. len.L.cHL for length of landings in the commercial hook and line fleet)
len_F_flt_abb <- local({
a <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\3",names(len_F_flt_mm),perl=TRUE)
gsub("^([^D.])([a-zA-Z]+)","L.\\1\\2",gsub("(.*?)(?<=.)(.D)$","D.\\1",a,perl=TRUE))
})
len_F_flt_units <- gsub("^([a-zA-Z]+)(.)(.*?)(.)([a-zA-Z]+)$","\\1.\\5",names(len_F_flt_mm),perl=TRUE)
names(len_F_flt_mm) <- names(len_F_flt_units) <- paste("len", #len_F_flt_units,
len_F_flt_abb,sep=".")
}
# Recompute landings by fleet to compare with calculations used in projections
Cn2 <- lapply(Cn,function(x){x*NA})
Cw2 <- lapply(Cw,function(x){x*NA})
for(i in 1:length(yb)){
for(j in 1:ncol(Fsum_flt)){
Cn2[[j]][i,] <- L_calc(F_flt[[j]][i,], Z[i,], N[i,])
Cw2[[j]][i,] <- L_calc(F_flt[[j]][i,], Z[i,], N[i,], wgt_F_flt_klb[[j]][i])
}
}
# CPUE
#   From bam tpl for SEDAR53:
#     N_cHL(iyear)=elem_prod(elem_prod(Nmdyr(iyear),sel_cHL(iyear)),wholewgt_cHL_klb(iyear));
#     pred_cHL_cpue(iyear)=q_cHL(iyear)*q_rate_fcn_cHL(iyear)*q_DD_fcn(iyear)*sum(N_cHL(iyear));
U_a <- list()
NU <- list()
unit_U <- list()
U_ts_pr <- t.series[paste(yb),grepl("^U.*pr$",names(t.series)),drop=FALSE]
U_ts_ob <- t.series[paste(yb),grepl("^U.*ob$",names(t.series)),drop=FALSE]
U_ts_cv <- t.series[paste(yb),grepl("^cv.U",names(t.series)),drop=FALSE] # cvs associated with U during the base years
# names(U_ts_pr) <- gsub("^(U.)(.*)(.)(pr)$","\\1\\4.\\2",names(U_ts_pr))
U_abb <- gsub("^U.|.pr$","",names(U_ts_pr))
names(U_ts_pr) <- names(U_ts_ob) <- U_abb
# Find q values in rdat
# Are the q values provided in t.series?
#q_nm <- paste0("q.",U_abb)
q_nm_tsY <- names(rdat$t.series)[grepl(paste0("^q..*(",paste(U_abb,collapse="|"),")$"),names(rdat$t.series))]#q_nm[q_nm%in%names(t.series)]
U_abb_tsY <- U_abb[unlist(lapply(U_abb,function(x){any(grepl(x,q_nm_tsY))}))]
U_abb_tsN <- U_abb[!U_abb%in%U_abb_tsY]
# q_nm_tsN <- q_nm[!q_nm%in%names(t.series)]
#q_nm_tsNpcY <- names(parm.cons)[grepl(paste0("^log.q..*(",paste(U_abb,collapse="|"),")$"),names(parm.cons))]#paste0("log.",q_nm_tsN)[paste0("log.",q_nm_tsN)%in%names(parm.cons)]
# q_nm_tsNpcN <- q_nm[which((!q_nm%in%names(t.series))&(!paste0("log.",q_nm)%in%names(parm.cons)))]
if(length(q_nm_tsY)>0){
q_mn <- t.series[paste(yb),q_nm_tsY,drop=FALSE]  # This is really a kind of mean q, since q_rate and q_DD_mult might scale it to compute U
}
# If any of the q values are not in t.series, look in parms.cons
if(length(U_abb_tsN)>0){
message(paste0("q values for ",paste(U_abb_tsN,collapse=", "), " index not found in t.series"))
q_nm_tsNpcY <- names(parm.cons)[grepl(paste0("^log.q..*(",paste(U_abb_tsN,collapse="|"),")$"),names(parm.cons))]
if(length(q_nm_tsNpcY)>0){
message(paste0("time invariant values ",paste(q_nm_tsNpcY,collapse=", "), " found in parm.cons will be exp transformed and used instead."))
U_abb_tsNpcY <- gsub(paste0("^(.*)(",paste(U_abb,collapse="|"),")"),"\\2",q_nm_tsNpcY)
q_tsNpcY <- setNames(exp(parm.cons[q_nm_tsNpcY][8,]),U_abb_tsNpcY)
# names(q_tsNpcY) <- gsub("^log.q.","",names(q_tsNpcY))
for(nm_i in names(q_tsNpcY)){
a <- U_ts_pr[,nm_i]
a[!is.na(a)] <- q_tsNpcY[[nm_i]]
q_mn[,paste0("q.",nm_i)] <- a
}
}else{
U_abb_tsNpcY <- NULL
}
# If any q not in t.series or parm.cons
U_abb_tsNpcN <- U_abb[!U_abb%in%c(U_abb_tsY,U_abb_tsNpcY)]
if(length(U_abb_tsNpcN)>0){
warning(paste0("q values for ",paste(U_abb_tsNpcN,collapse=", "), " not found in t.series or parm.cons. Can't compute these cpue indices in the projections."))
}
}
q_DD_mult <- t.series[paste(yb),"q.DD.mult",drop=FALSE] # density dependent function as a multiple of q (scaled a la Katsukawa and Matsuda. 2003)
q_rate <- q_mn*0+1
q <- q_mn*NA # Initialize values for final q value (q_mn * q_rate * q_DD_mult) multiplied by N to compute CPUE
U_abb
sel_age_2
names(sel_age_2)
U_abb
sel_U <- sel_age_2[which(gsub("sel.[vm].","",names(sel_age_2))%in%U_abb)]
sel_U
sel_age_1
sel_U <- sel_age_2[which(gsub("sel.[vm].","",names(sel_age_2))%in%U_abb)]
names(sel_U)
U_abb
names(sel_age_2)
library(bamExtras)
setwd("~/GitHub/myPackages/bamExtras/TEST_FOLDER/comprehensive testing")
# Chunk 1: global_options
rm(list=ls())
library(bamExtras)
#devtools::install_github("mtvincen/FishGraph")
library(FishGraph)
library(knitr)
library(doParallel)
library(foreach)
library(msm)
opts_chunk$set(comment=NA,echo=FALSE,message=FALSE,warning=FALSE,fig.height=6,fig.width=6)
wd <- getwd()
# Chunk 2: user
commonName <- c(
"AtlanticMenhaden",
"BlackSeaBass",
"BluelineTilefish",
"Cobia",
"GagGrouper",
"GrayTriggerfish",
"GreaterAmberjack",
"RedGrouper",
"RedPorgy",
"RedSnapper",
"ScampGrouper",
"SnowyGrouper",
"SpanishMackerel",
"Tilefish",
"VermilionSnapper"
)
commonNameAbb <- abbreviate(commonName)
random_seed <- 12345
coresUse <- NULL
dir_base <- "base"
# Chunk 3: parallel setup
# parallel setup
if(is.null(coresUse)){
coresAvail <- detectCores()
coresUse <- coresAvail-1
}
coresUse  <- min(c(coresUse,coresAvail))
cl <- makeCluster(coresUse)
registerDoParallel(cl)
# Chunk 4: functions
# Similar to car::logit
logit <- function(x,adjust=0.0001){
x[x==0] <- x[x==0]+adjust
x[x==1] <- x[x==1]-adjust
log(x/(1-x))
}
# Chunk 5: set up results folders
if(!dir.exists(dir_base)){
dir.create(dir_base)
}
# Chunk 6: bam2r
# run bam2r
bam <- foreach(i=1:length(commonName),
.packages=c("bamExtras")) %dopar% {
commonName_i    <- commonName[i]
out_i <- bam2r(CommonName = commonName_i)
return(out_i)
}
names(bam) <- commonNameAbb
# Chunk 7: look for objects in init files
obs_maturity_f <- lapply(bam,function(x){
# names(x$init)[grepl("maturity",names(x$init))]
a <- x$init$obs_maturity_f
b <- as.numeric(a)
attributes(b) <- attributes(a)
b
})
# Estimate maturity curve
nfish <- 1000
yP <- obs_maturity_f$BlSB
y1 <- round(nfish*yP)
y0 <- round(nfish*(1-yP))
# y <- c(rep(0,round(sum(y0*nfish))),rep(1,round(sum(y1*nfish))))
x <- as.numeric(names(yP))
dataCt <- data.frame(x,y1,y0)
data <- data.frame(x=c(rep(x,y0),rep(x,y1)),y=c(rep(0,sum(y0)),rep(1,sum(y1))))
fit1 <- glm(y~x,data=data,family="binomial")
x_pr <- data.frame(x=seq(min(x),max(x),length=100))
x2_pr <- data.frame(x=seq(min(x),max(x),length=100))*.5
y_pr <- predict(fit,newdata = x_pr,type="response")
y2_pr <- predict(fit,newdata = x2_pr,type="response")
plot(x,yP)
points(x_pr$x,y_pr,type="l")
points(x2_pr$x,y_pr,type="l")
rep(x,round(nfish*y))
plot(x,y1,type="o")
points(x,y2,type="o",col="red")
points(x,y3,type="o",col="blue")
# Chunk 8: run_bam
# Run bam base models
base <- foreach(i=1:length(commonName),
.packages=c("bamExtras")) %dopar% {
commonName_i    <- commonName[i]
commonNameAbb_i <- as.character(commonNameAbb[i])
rdat_i <- run_bam(CommonName = commonName_i,
fileName = commonNameAbb_i,
unlink_dir_bam=FALSE)
file.copy(
from=commonNameAbb_i,
to="base",
overwrite = TRUE,
recursive = TRUE)
unlink(commonNameAbb_i,recursive = TRUE)
return(rdat_i)
}
names(base) <- commonNameAbb
setwd(wd)
# Chunk 9: plot_bam
# Plot bam base models
for(i in names(base_out)){
dir_base_i <- file.path("base",i)
if(!dir.exists(dir_base_i)){
dir.create(dir_base_i, recursive = TRUE)
}
setwd(dir_base_i)
plot_bam(base_out[[i]]$rdat)
setwd(wd)
}
library(bamExtras)
