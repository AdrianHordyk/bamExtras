#               nrow=nyp,dimnames=list(paste(yp),names(C_ts_cv)))
#   # rownames(a) <- paste(yp)
#   a
# })
#
# U_ts_cv_p <- local({
#   a <- matrix(apply(U_ts_cv,2,function(x){rep(bamExtras::geomean2(tail(x,nyb_rcn$U)),nyp)}),
#               nrow=nyp,dimnames=list(paste(yp),names(U_ts_cv)))
#   # rownames(a) <- paste(yp)
#   a
# })
# Add projected values to base values
N <- rbind(N,N_p)
R <- c(R,R_p)
# U <- rbind(U,U_p)
C_ts_cv <- rbind(C_ts_cv,C_ts_cv_p)
U_ts_cv <- rbind(U_ts_cv,U_ts_cv_p)
nfish <- rbind(nfish,nfish_p)
ntrip <- rbind(ntrip,ntrip_p)
lcomp <- local({
a <- lapply(seq_along(names(lcomp_b_ob)),function(x){
nm_x <- names(lcomp_b_ob)[x]
ax <- rbind(lcomp_b_ob[[x]],lcomp_p[[x]])
ax[complete.cases(ax),,drop=FALSE]
})
names(a) <- names(lcomp_b_ob)
a
})
acomp <- local({
a <- lapply(seq_along(names(acomp_b_ob)),function(x){
nm_x <- names(acomp_b_ob)[x]
ax <- rbind(acomp_b_ob[[x]],acomp_p[[x]])
ax[complete.cases(ax),,drop=FALSE]
})
names(a) <- names(acomp_b_ob)
a
})
Fsum <- c(Fsum,Fsum_p)
for(nm_i in names(Cn)){
Cn[[nm_i]] <- rbind(Cn[[nm_i]],Cn_p[[nm_i]])
}
for(nm_i in names(Cw)){
Cw[[nm_i]] <- rbind(Cw[[nm_i]],Cw_p[[nm_i]])
}
} # end if nyp>0
B <- wgt_mt*N
Nsum <- rowSums(N)
Bsum <- rowSums(B)
# Values by fleet  in long format (for ggplot)
# Landings (n)
Cn.L <- local({
a <- as.data.frame(lapply(Cn[grepl("^Cn.L.",names(Cn))],rowSums))
b <- cbind("year"=as.numeric(rownames(a)),a)
colnames(b) <- gsub("Cn.L.","",colnames(b))
gather(data=b,key=fleet,value=Ln,names(b)[names(b)!="year"],factor_key = TRUE)
})
# Discards (n)
Cn.D <- local({
a <- as.data.frame(lapply(Cn[grepl("^Cn.D.",names(Cn))],rowSums))
b <- cbind("year"=as.numeric(rownames(a)),a)
colnames(b) <- gsub("Cn.D.","",colnames(b))
gather(data=b,key=fleet,value=Dn,names(b)[names(b)!="year"],factor_key = TRUE)
})
# Landings (w)
Cw.L <- local({
a <- as.data.frame(lapply(Cw[grepl("^Cw.L.",names(Cw))],rowSums))
b <- cbind("year"=as.numeric(rownames(a)),a)
colnames(b) <- gsub("Cw.L.","",colnames(b))
gather(data=b,key=fleet,value=Lw,names(b)[names(b)!="year"],factor_key = TRUE)
})
# Discards (w)
Cw.D <- local({
a <- as.data.frame(lapply(Cw[grepl("^Cw.D.",names(Cw))],rowSums))
b <- cbind("year"=as.numeric(rownames(a)),a)
colnames(b) <- gsub("Cw.D.","",colnames(b))
gather(data=b,key=fleet,value=Dw,names(b)[names(b)!="year"],factor_key = TRUE)
})
Cn.L.tot <- tapply(Cn.L[,"Ln"],Cn.L[,"year"],sum)
Cw.L.tot <- tapply(Cw.L[,"Lw"],Cw.L[,"year"],sum)
if(nrow(Cn.D)>0){
Cn.D.tot <- tapply(Cn.D[,"Dn"],Cn.D[,"year"],sum)
Cw.D.tot <- tapply(Cw.D[,"Dw"],Cw.D[,"year"],sum)
}else{
Cn.D.tot <- NULL
Cw.D.tot <- NULL
}
#############################################################
###### Extend data inputs and build projected dat file ######
#############################################################
# Identify the parts of init that need to be changed
# Identify the new parts and match them with the parts that need to change
if(!is.null(bam2r_args)){
bam <- do.call(bam2r,bam2r_args)
init_p <- init_b <- bam$init
### Identify temporal objects in init that need to change
## Check to see if life history inputs are time varying. If so extend them accordingly
# maturity
obs_maturity_nm <- names(init_p)[grepl("^obs_maturity",names(init_p))]
if(length(obs_maturity_nm)>0){
for(nm_i in obs_maturity_nm){
xi <- init_p[[nm_i]]
if(is.matrix(xi)){
message(paste0(nm_i," is a matrix"))
# Check if rownames are equal to model years (they should be if it is time varying)
if(all(dimnames(xi)[[1]]==paste(yb))){
message(paste0(nm_i," appears to be time varying. endyr values will be projected"))
xi_p <- matrix(xi[paste(endyr),],nrow=nyp,ncol=ncol(xi),dimnames=list(paste(yp),dimnames(xi)[[2]]),byrow=TRUE)
init_p[[nm_i]] <- rbind(xi,xi_p)
}else{
warning(paste0("rownames of ",nm_i," are not equal to model years"))
}
}
}
}
# proportion female or male
obs_prop_nm <- names(init_p)[grepl("^obs_prop_[fmFM]",names(init_p))]
if(length(obs_prop_nm)>0){
for(nm_i in obs_prop_nm){
xi <- init_p[[nm_i]]
if(is.matrix(xi)){
message(paste0(nm_i," is a matrix"))
# Check if rownames are equal to model years (they should be if it is time varying)
if(all(dimnames(xi)[[1]]==paste(yb))){
message(paste0(nm_i," appears to be time varying. endyr values will be projected"))
xi_p <- matrix(xi[paste(endyr),],nrow=nyp,ncol=ncol(xi),dimnames=list(paste(yp),dimnames(xi)[[2]]),byrow=TRUE)
init_p[[nm_i]] <- rbind(xi,xi_p)
}else{
warning(paste0("rownames of ",nm_i," are not equal to model years"))
}
}
}
}
# natural mortality-at-age
set_M_nm <- names(init_p)[grepl("^set_M",names(init_p))]
if(length(set_M_nm)>0){
for(nm_i in set_M_nm){
xi <- init_p[[nm_i]]
if(is.matrix(xi)){
message(paste0(nm_i," is a matrix"))
# Check if rownames are equal to model years (they should be if it is time varying)
if(all(dimnames(xi)[[1]]==paste(yb))){
message(paste0(nm_i," appears to be time varying. endyr values will be projected"))
xi_p <- matrix(xi[paste(endyr),],nrow=nyp,ncol=ncol(xi),dimnames=list(paste(yp),dimnames(xi)[[2]]),byrow=TRUE)
init_p[[nm_i]] <- rbind(xi,xi_p)
}else{
warning(paste0("rownames of ",nm_i," are not equal to model years"))
}
}
}
}
# I'll have to do some more monkeying around to deal with the tv objects in menhaden
# mostly because they have wierd names
# tv (time varying objects currently in Atlantic Menhaden model)
# init_tv <- init_b[grepl("_tv$",names(init_b))]
#### Update temporal values
## _endyr
# Any _endyr for select values and for data sets that extend to the terminal
# year of the assessment should be extended by nyp
yr_nm_add_p <- local({
a <- c("endyr","endyr_rec_dev","endyr_rec_phase2","endyr_rec_spr","styr_regs","endyr_proj"
#,names(init_endyr[grepl("^endyr_([DL]|cpue)",names(init_endyr))&as.numeric(init_endyr)>=endyr])
)
a[a%in%names(init_b)]
})
init_p[yr_nm_add_p] <- lapply(init_p[yr_nm_add_p],function(x){paste(as.numeric(x)+nyp)})
yrs_rec_dev <- init_p$styr_rec_dev:init_p$endyr_rec_dev
init_p[["set_log_dev_vals_rec"]] <- setNames(rep("0.0",length(yrs_rec_dev)),yrs_rec_dev)
## landings
# Note: need to make sure you get the right units (n or w)
init_obs_L_nm <- names(init_b)[grepl("^obs_L",names(init_b))]
for(nm_i in init_obs_L_nm){
abb_i <- gsub("^(obs_L)(_)(.*)","\\3",nm_i)
xbi <- setNames(as.numeric(init_b[[nm_i]]),names(init_b[[nm_i]]))
yrsbi <- names(xbi)
xni <- rowSums(Cn[[paste0("Cn.L.",abb_i)]])
xkwi <- rowSums(Cw[[paste0("Cw.L.",abb_i)]]) # weights are usually 1000 lbs in CLD.est.mats
xkni <- xni/1000
xwi <- xkwi*1000
xcvi <- init_b[[paste0("obs_cv_L_",abb_i)]]
# Compute the sums of squared deviations to determine whether landings are
# in numbers or in weight. Landings in the appropriate units are then added
# to the observed landings to add to the new dat file.
SSxbi <- unlist(lapply(list(xni=xni,xwi=xwi,xkni=xkni,xkwi=xkwi),function(x){sum((x[yrsbi]-xbi)^2)}))
ndigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xbi))))
# ndigcvi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xcvi))))
xpi <- round(get(names(SSxbi)[which.min(SSxbi)])[paste(yp)],ndigi)
# If the last year of xbi was the last year of the base model, then project it forward
if(paste(endyr)%in%names(xbi)){
xi <- c(xbi,xpi)
}else{
xi <- xbi
}
init_p[[nm_i]] <- setNames(paste(xi),names(xi))
# reset appropriate _endyr value to make sure it agrees with the projected data (some endyr values might get projected even if the data doesn't)
endyr_nm_i <- paste0("endyr_L_",abb_i)
if(endyr_nm_i%in%names(init_p)){init_p[[endyr_nm_i]] <- tail(names(xi),1)}
init_p[[paste0("obs_cv_L_",abb_i)]] <- local({
# setNames(paste(round(C_ts_cv[,paste0("cv.L.",abb_i)],ndigcvi)),rownames(C_ts_cv))[names(xi)]
a <- setNames(as.numeric(init_p[[nm_i]])*NA,names(init_p[[nm_i]]))
b <- init_b[[paste0("obs_cv_L_",abb_i)]]
a[names(b)] <- b
c <- bamExtras::geomean2(tail(b,nyb_rcn$L))
d <- paste(yp)[paste(yp)%in%names(a)]
a[d] <- c
a
})
## set_log_dev_vals_F_L
set_log_dev_vals_F_L_nm_i <- paste0("set_log_dev_vals_F_L_",abb_i)
if(set_log_dev_vals_F_L_nm_i%in%names(init_b)){
init_p[[set_log_dev_vals_F_L_nm_i]] <- setNames(rep("0.0",length(xi)),names(xi))
}
}
## discards
# Note: Assumed to be in numbers
init_obs_released_nm <- names(init_b)[grepl("^obs_released",names(init_b))]
for(nm_i in init_obs_released_nm){
abb_i <- gsub("^(obs_released)(_)(.*)","\\3",nm_i)
xbi <- setNames(as.numeric(init_b[[nm_i]]),names(init_b[[nm_i]]))
yrsbi <- names(xbi)
# If the name of the time series in the init object matches a name reported in the model output (Cn),
# use the corresponding time series from Cn for the init object in the projection
# NOTE: These if else statements were included as a workaround to accommodate the Black Sea Bass model
if(paste0("Cn.D.",abb_i)%in%names(Cn)){
DMi_nm <- paste0("set_Dmort_",abb_i)
xni_dead <- rowSums(Cn[[paste0("Cn.D.",abb_i)]])
if(DMi_nm%in%names(init_b)){
DMi <- as.numeric(init_b[[paste0("set_Dmort_",abb_i)]])
}else{
DMi <- mean(xni_dead[yrsbi]/1000/xbi,na.rm=TRUE)
}
xni <- xni_dead*1/DMi # Convert to released (live discards)
xkni <- xni/1000
}else{ # ..but if not, compute the init object in the projection as a function init object i
# from the base and the most similar time series from Cn
ft_i <- gsub("^([cr]).*","\\1",abb_i) # identify fleet type i should be "c" or "r"
# sum all discard matrices in Cn with fleet_type_i and sum by year across ages
Cn_ts_ft_i <- rowSums(Reduce(sum,Cn[names(Cn)[grepl(paste0("^(Cn.D.",ft_i,").*"),names(Cn))]]))
# identify init time series with ft_i
init_b_released_ft_i <- local({
a <- init_b[init_obs_released_nm[grepl(paste0("^(obs_released_",ft_i,").*"),init_obs_released_nm)]]
c <- lapply(a,function(x){
b <- setNames(rep(0,nyb),paste(yb))
b[names(x)] <- as.numeric(x)
b
}
)
as.data.frame(c)
})
# Estimate total released (i.e. live discards) during the base model years
Ckn_ts_ft_i <- Cn_ts_ft_i[paste(yb)]/1000
released_tot_obs_kn_i <- rowSums(init_b_released_ft_i)
Dm_ts_i <- Ckn_ts_ft_i/released_tot_obs_kn_i # Annual Dmort
Dm_ts_i[!is.finite(Dm_ts_i)] <- NA
Cn_released_b_ft_i <- 1000*Ckn_ts_ft_i*1/Dm_ts_i
# Compute observed released (live discards) as a proportion of total released in ft_i
init_b_released_prop_ft_i <- init_b_released_ft_i/rowSums(init_b_released_ft_i)
# Estimate xni_b from values that can be used in projections
xni_b <- Cn_released_b_ft_i*init_b_released_prop_ft_i[,nm_i]
xni_b[!is.finite(xni_b)] <- 0
xkni_b <- xni_b/1000
# Estimate xni for projection years
Cn_released_p_ft_i <- (Cn_ts_ft_i[paste(yp)])*(1/mean(Dm_ts_i[paste(tail(yb,nyb_rcn$L))]))
xni_p <- Cn_released_p_ft_i*mean(init_b_released_prop_ft_i[paste(tail(yb,nyb_rcn$L)),nm_i])
xkni_p <- xni_p/1000
xni <- c(xni_b,xni_p)
xkni <- c(xkni_b,xkni_p)
}
xcvi <- init_b[[paste0("obs_cv_D_",abb_i)]]
SSxbi <- unlist(lapply(list(xni=xni,xkni=xkni
#xkwi=xkwi,xwi=xwi
),function(x){sum((x[yrsbi]-xbi)^2)}))
ndigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xbi))))
# ndigcvi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xcvi))))
xpi <- round(get(names(SSxbi)[which.min(SSxbi)])[paste(yp)],ndigi)
# If the last year of xbi was the last year of the base model, then project it forward
if(paste(endyr)%in%names(xbi)){
xi <- c(xbi,xpi)
}else{
xi <- xbi
}
init_p[[nm_i]] <- setNames(paste(xi),names(xi))
# reset appropriate _endyr value to make sure it agrees with the projected data (some endyr values might get projected even if the data doesn't)
endyr_nm_i <- paste0("endyr_D_",abb_i)
if(endyr_nm_i%in%names(init_p)){init_p[[endyr_nm_i]] <- tail(names(xi),1)}
}
## set_log_dev_vals_F_D
init_set_log_dev_vals_F_D_nm <- names(init_b)[grepl("^set_log_dev_vals_F_D",names(init_b))]
for(nm_i in init_set_log_dev_vals_F_D_nm){
vals_b_i <- init_b[[nm_i]]
# If the value was provided in the last year of the base model, project it forward
if(paste(endyr)%in%names(vals_b_i)){
vals_p_i <- setNames(rep("0.0",nyp),yp)
vals_i <- c(vals_b_i,vals_p_i)
}else{
vals_i <- vals_b_i
}
init_p[[nm_i]] <- vals_i
}
## discard cvs
#  This is done in a separate loop because the discard cvs don't always match discard time series supplied to the dat file
#  (e.g. Black Sea Bass SEDAR 56)
init_obs_cv_D_nm <- names(init_b)[grepl("^obs_cv_D",names(init_b))]
for(nm_i in init_obs_cv_D_nm){
obs_cv_D_b_i <- init_b[[nm_i]]
# If the cv was provided in the last year of the base model, project it forward
if(paste(endyr)%in%names(obs_cv_D_b_i)){
obs_cv_D_p_i <- setNames(rep(bamExtras::geomean2(tail(obs_cv_D_b_i,nyb_rcn$L)),nyp),yp)
obs_cv_D_i <- c(obs_cv_D_b_i,obs_cv_D_p_i)
}else{
obs_cv_D_i <- obs_cv_D_b_i
}
init_p[[nm_i]] <- obs_cv_D_i
}
## cpue
init_obs_cpue_nm <- local({
nm <- names(init_b)[grepl("^obs_cpue",names(init_b))]
nm_abb <- gsub("^(obs_cpue)(_)(.*)","\\3",nm)
nm_yes <- nm[which(nm_abb%in%dimnames(U)[[2]])]
nm_no <- nm[which(!nm_abb%in%dimnames(U)[[2]])]
if(length(nm_no)>0){
message(paste(paste(nm_no,collapse=", "), "were found in the bam tpl but not in the rdat. They may not be included in the likelihood."))
}
# Only include names found in U (indices reported in the rdat)
return(nm_yes)
})
for(nm_i in init_obs_cpue_nm){
abb_i <- gsub("^(obs_cpue)(_)(.*)","\\3",nm_i)
xbi <- setNames(as.numeric(init_b[[nm_i]]),names(init_b[[nm_i]]))
yrsbi <- names(xbi)
xproji <- setNames(U[,abb_i],dimnames(U)[[1]])
xcvi <- init_b[[paste0("obs_cv_cpue_",abb_i)]]
ndigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xbi))))
ndigcvi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xcvi))))
xpi <- round(xproji[paste(yp)],ndigi)
xi <- c(xbi,xpi[!is.na(xpi)])
yrsi <- names(xi)
init_p[[nm_i]] <- setNames(paste(xi),names(xi))
init_p[[paste0("obs_cv_cpue_",abb_i)]] <- setNames(paste(round(U_ts_cv[,paste0("cv.U.",abb_i)],ndigcvi)),rownames(U_ts_cv))[names(xi)]
# update styr, endyr, yrs, and nyr as necessary
yrinfoi <- setNames(list(min(yrsi),max(yrsi),yrsi,paste(length(yrsi))),
paste0(c("styr","endyr","yrs","nyr"),gsub("obs","",nm_i))
)
yrinfoi_nm_is <- names(yrinfoi)[names(yrinfoi)%in%names(init_p)]
init_p[yrinfoi_nm_is] <- yrinfoi[yrinfoi_nm_is]
}
## agec
init_obs_agec_nm <- names(init_b)[grepl("^obs_agec",names(init_b))]
init_obs_agec_nm_key <- setNames(names(acomp),
paste0("obs_agec_",gsub("^(D.)([A-Za-z]+)","\\2_D",gsub("^L.","",names(acomp)))))
for(nm_i in init_obs_agec_nm){
nm2_i <- init_obs_agec_nm_key[[nm_i]]
xbi <- init_b[[nm_i]]
x2bi <- acomp[[nm2_i]]
ndigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xbi))))
obsi <- apply(x2bi,2,function(x){sprintf(paste0("%.",ndigi,"f"), x)})
attributes(obsi) <- attributes(x2bi)
yrsi <- rownames(obsi)
init_p[[nm_i]] <- obsi
# update styr, endyr, yrs, and nyr as necessary
yrinfoi <- setNames(list(min(yrsi),max(yrsi),yrsi,paste(length(yrsi))),
paste0(c("styr","endyr","yrs","nyr"),gsub("obs","",nm_i))
)
yrinfoi_nm_is <- names(yrinfoi)[names(yrinfoi)%in%names(init_p)]
init_p[yrinfoi_nm_is] <- yrinfoi[yrinfoi_nm_is]
# update nfish and nsamp as necessary
nfish_nm_i <- gsub("obs","nfish",nm_i)
nsamp_nm_i <- gsub("obs","nsamp",nm_i)
nfishbi <- init_b[[nfish_nm_i]]
nsampbi <- init_b[[nsamp_nm_i]]
nfishpi <- setNames(rep(bamExtras::geomean2(nfishbi[paste(tail(yb,nyb_rcn$comp))]),nyp),paste(yp))
nsamppi <- setNames(rep(bamExtras::geomean2(nsampbi[paste(tail(yb,nyb_rcn$comp))]),nyp),paste(yp))
nfishdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nfishbi))))
nsampdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nsampbi))))
nfishi <- setNames(sprintf(paste0("%.",nfishdigi,"f"),round(as.numeric(c(nfishbi,nfishpi)))),names(c(nfishbi,nfishpi)))
nsampi <- setNames(sprintf(paste0("%.",nsampdigi,"f"),round(as.numeric(c(nsampbi,nsamppi)))),names(c(nsampbi,nsamppi)))
init_p[[nfish_nm_i]] <- nfishi[yrsi]
init_p[[nsamp_nm_i]] <- nsampi[yrsi]
}
## lenc
init_obs_lenc_nm <- names(init_b)[grepl("^obs_lenc",names(init_b))]
init_obs_lenc_nm_key <- setNames(names(lcomp),
paste0("obs_lenc_",gsub("^(D.)([A-Za-z]+)","\\2_D",gsub("^L.","",names(lcomp)))))
# for(nm_i in init_obs_lenc_nm){
#   nm2_i <- init_obs_lenc_nm_key[[nm_i]]
#   xbi <- init_b[[nm_i]]
#   x2bi <- lcomp[[nm2_i]]
#   ndigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xbi))))
#   obsi <- apply(x2bi,2,function(x){sprintf(paste0("%.",ndigi,"f"), x)})
#   dimnames(obsi) <- dimnames(x2bi)
#   yrsi <- rownames(obsi)
#   init_p[[nm_i]] <- obsi
#   # update styr, endyr, yrs, and nyr as necessary
#   yrinfoi <- setNames(list(min(yrsi),max(yrsi),yrsi,paste(length(yrsi))),
#                       paste0(c("styr","endyr","yrs","nyr"),gsub("obs","",nm_i))
#   )
#   yrinfoi_nm_is <- names(yrinfoi)[names(yrinfoi)%in%names(init_p)]
#   init_p[yrinfoi_nm_is] <- yrinfoi[yrinfoi_nm_is]
#
#   # update nfish and nsamp as necessary
#   nfish_nm_i <- gsub("obs","nfish",nm_i)
#   nsamp_nm_i <- gsub("obs","nsamp",nm_i)
#   nfishbi <- init_b[[nfish_nm_i]]
#   nsampbi <- init_b[[nsamp_nm_i]]
#   nfishdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nfishbi))))
#   nsampdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nsampbi))))
#   nfish2i <- setNames(sprintf(paste0("%.",nfishdigi,"f"), nfish[,paste0("lcomp.",nm2_i)]),rownames(nfish))
#   nsamp2i <- setNames(sprintf(paste0("%.",nsampdigi,"f"), ntrip[,paste0("lcomp.",nm2_i)]),rownames(ntrip))
#
#
#   init_p[[nfish_nm_i]] <- nfish2i[yrsi]
#   init_p[[nsamp_nm_i]] <- nsamp2i[yrsi]
# }
for(nm_i in init_obs_lenc_nm){
nm2_i <- init_obs_lenc_nm_key[[nm_i]]
xbi <- init_b[[nm_i]]
x2bi <- lcomp[[nm2_i]]
ndigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",xbi))))
obsi <- apply(x2bi,2,function(x){sprintf(paste0("%.",ndigi,"f"), x)})
attributes(obsi) <- attributes(x2bi)
yrsi <- rownames(obsi)
init_p[[nm_i]] <- obsi
# update styr, endyr, yrs, and nyr as necessary
yrinfoi <- setNames(list(min(yrsi),max(yrsi),yrsi,paste(length(yrsi))),
paste0(c("styr","endyr","yrs","nyr"),gsub("obs","",nm_i))
)
yrinfoi_nm_is <- names(yrinfoi)[names(yrinfoi)%in%names(init_p)]
init_p[yrinfoi_nm_is] <- yrinfoi[yrinfoi_nm_is]
# update nfish and nsamp as necessary
nfish_nm_i <- gsub("obs","nfish",nm_i)
nsamp_nm_i <- gsub("obs","nsamp",nm_i)
nfishbi <- init_b[[nfish_nm_i]]
nsampbi <- init_b[[nsamp_nm_i]]
nfishpi <- setNames(rep(bamExtras::geomean2(nfishbi[paste(tail(yb,nyb_rcn$comp))]),nyp),paste(yp))
nsamppi <- setNames(rep(bamExtras::geomean2(nsampbi[paste(tail(yb,nyb_rcn$comp))]),nyp),paste(yp))
nfishdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nfishbi))))
nsampdigi <- round(median(nchar(gsub("([0-9]*.)([0-9]*)","\\2",nsampbi))))
nfishi <- setNames(sprintf(paste0("%.",nfishdigi,"f"),round(as.numeric(c(nfishbi,nfishpi)))),names(c(nfishbi,nfishpi)))
nsampi <- setNames(sprintf(paste0("%.",nsampdigi,"f"),round(as.numeric(c(nsampbi,nsamppi)))),names(c(nsampbi,nsamppi)))
init_p[[nfish_nm_i]] <- nfishi[yrsi]
init_p[[nsamp_nm_i]] <- nsampi[yrsi]
}
bam_p <- bam2r(dat_obj=bam$dat,tpl_obj=bam$tpl,cxx_obj=bam$cxx,init=init_p)
}else{
bam_p <- NULL
} # end if(!is.null(bam2r_args))
# plot stuff
if(plot){
par(mfrow=c(2,2),mar=c(3,3,1,1),mgp=c(1,0.2,0),tck=-0.01)
# N
plot(as.numeric(names(Nsum)),Nsum,type="o")
abline(v=endyr)
# R
plot(as.numeric(names(R)),R,type="o")
abline(v=endyr)
# B
plot(as.numeric(names(Bsum)),Bsum,type="o")
abline(v=endyr)
# Fsum
plot(as.numeric(names(Fsum)),Fsum,type="o")
abline(v=endyr)
# Landings and discards
# Cn.L
p <- ggplot(Cn.L,mapping=aes(x=year,y=Ln))+
geom_area(aes(fill=fleet))+
theme_bw()+
scale_fill_brewer(palette="Spectral")+
stat_summary(fun = sum, geom = "line", size = 1)+
stat_summary(fun = sum, geom = "point", size = 2)+
geom_vline(xintercept = endyr, linetype="dashed", size = 0.3)
p2 <- p + geom_text(aes(x=endyr, label="endyr\n",y=max(Ln)), angle=90)
print(p2)
# Cn.D
if(nrow(Cn.D)>0){
p2 <- p %+% Cn.D + aes(y=Dn) +
geom_text(aes(x=endyr, label="endyr\n",y=max(Dn)), angle=90)
print(p2)
}
# Cw.L
p2 <- p %+% Cw.L + aes(y=Lw) +
geom_text(aes(x=endyr, label="endyr\n",y=max(Lw)), angle=90)
print(p2)
# Cw.D
if(nrow(Cw.D)>0){
p2 <- p %+% Cw.D + aes(y=Dw) +
geom_text(aes(x=endyr, label="endyr\n",y=max(Dw)), angle=90)
print(p2)
}
# cpue
matplot(as.numeric(dimnames(U)[[1]]),U,type="o",xlab="",xlim=c(styr,endyr+nyp),pch=1)
# matpoints(as.numeric(rownames(U_p)),U_p,type="o",pch=1)
legend("topleft",legend=dimnames(U)[[2]],col=1:ncol(U),lty=1:ncol(U),pch=1)
abline(v=endyr)
}
# Return results
names(U_p) <- paste0("U_",names(U_p))
library(bamExtras)
setwd("~/GitHub/myPackages/bamExtras/TEST_FOLDER/run_proj")
source("~/GitHub/myPackages/bamExtras/TEST_FOLDER/run_proj/run_proj_test.r")
source("~/GitHub/myPackages/bamExtras/TEST_FOLDER/run_proj/run_proj_test.r")
setwd("~/GitHub/myPackages/bamExtras/TEST_FOLDER/run_proj_seq")
source("~/GitHub/myPackages/bamExtras/TEST_FOLDER/run_proj_seq/run_proj_seq_test.r")
View(L_calc)
setwd("~/GitHub/myPackages/bamExtras/R")
?build_manaul
library(devtools)
?build_manaul
?build_manual
build_manual("bamExtras")
build_manual()
rlan::last_error()
rlang::last_error()
rlang::last_trace()
