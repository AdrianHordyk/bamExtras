return(comp_list)
}
comp_complete <- function(comp_list,comp_data_n,xBinByDataframe=FALSE,
n_tag= c("n","nfish"),
n_colname_new= c("ntrip","nfish"),
val_rownames=NULL,
val_colnames=NULL,
output_type="prop",
minusGroup=FALSE,
plusGroup=FALSE,
valsToNA=-99999){
rownames_all <- sort(unique(unlist(lapply(comp_list,rownames))))
colnames_all <- paste(sort(as.numeric(unique(unlist(lapply(comp_list,colnames))))))
if(is.null(val_rownames)){
val_rownames <- paste(min(as.numeric(rownames_all)):max(as.numeric(rownames_all)))
}
if(is.null(val_colnames)){
val_colnames <- colnames_all
}
for (compName_i in names(comp_list)){
M_i <- comp_list[[compName_i]]
colnames_obs_i <- colnames(M_i)
if(xBinByDataframe){
val_colnames_i <- colnames(M_i)
}else{
val_colnames_i <- val_colnames
}
# Identify the specific row and column names missing comp matrix i
row_missing <- val_rownames[!val_rownames%in%rownames(M_i)]
col_missing <- val_colnames_i[!val_colnames_i%in%colnames(M_i)]
## Add missing rows
# Create empty matrix of missing rows
M_row_missing <- matrix(NA,nrow=length(row_missing),ncol=ncol(M_i),dimnames=list(row_missing,colnames(M_i)))
# Actually add missing rows and columns to comp matrix i
M_i2 <- rbind(M_i,M_row_missing)
M_i2 <- local({M_i2 %>% rownames %>% order -> o; M_i2[o,]}) # Sort rows of M_i2
## Add missing columns
# Create empty matrix of missing columns
M_col_missing <- matrix(NA,nrow=nrow(M_i2),ncol=length(col_missing),dimnames=list(row.names(M_i2),col_missing))
# Actually add missing rows and columns to comp matrix i
M_i3 <- cbind(M_i2,M_col_missing)
M_i3 <- local({M_i3 %>% colnames %>% as.numeric %>% order -> o; M_i3[,o]}) # Sort columns of M_i3
# Add minus group if specified, and if data are going to be truncated
# (by default, function simply excludes values below minimum val_colnames_i)
if(minusGroup&min(as.numeric(val_colnames_i))>min(as.numeric(colnames_obs_i))){
M_i3_minus <- M_i3[,as.numeric(colnames_obs_i) <= min(as.numeric(val_colnames_i)),drop=FALSE]
M_i3[,paste(min(as.numeric(val_colnames_i)))] <-  rowSums(M_i3_minus) # Add plus group values
M_i3[which(!is.na(rowSums(M_i3))),which(as.numeric(colnames_obs_i) < min(as.numeric(val_colnames_i)))] <- 0 # Replace values in bins above with zeros
}
# Add plus group if specified, and if data are going to be truncated
# (by default, function simply excludes values above maximum val_colnames_i)
if(plusGroup&max(as.numeric(val_colnames_i))<max(as.numeric(colnames_obs_i))){
M_i3_plus <- M_i3[,as.numeric(colnames_obs_i) >= max(as.numeric(val_colnames_i)),drop=FALSE]
M_i3[,paste(max(as.numeric(val_colnames_i)))] <-  rowSums(M_i3_plus) # Add plus group values
M_i3[which(!is.na(rowSums(M_i3))),which(as.numeric(colnames_obs_i) > max(as.numeric(val_colnames_i)))] <- 0 # Replace values in bins above with zeros
}
# Replace NA in rows (years) with data with zeros
M_i3 <- t(apply(M_i3, 1, function(x){
if(all(is.na(x))){
x}else{
x[is.na(x)] <- 0
x
}
}))
M_out_i <- matrix(NA,nrow=length(val_rownames),ncol=length(val_colnames_i),dimnames=list(val_rownames,val_colnames_i))
# Add observed values to the appropriate cells in the output matrix
for(obs_rowName_j in rownames(M_i3)[which(rownames(M_i3)%in%rownames(M_out_i))]){
obs_colname_i <- colnames(M_i3)[which(colnames(M_i3)%in%colnames(M_out_i))]
#M_out_i[obs_rowName_j,] <- rep(0,ncol(M_out_i)) # First fill with zeros
# Linear interpolation to match val_colnames_i (won't change anything if existing column names are desired)
x_ij <- M_i3[obs_rowName_j,]
y_ij <- rep(NA,length(val_colnames_i))
if(any(!is.na(x_ij))){
y_ij <- approx(as.numeric(names(x_ij)),x_ij,xout = as.numeric(val_colnames_i))$y
}
M_out_i[obs_rowName_j,] <- y_ij # Now fill with observed data
}
M_out_i <- t(apply(M_out_i,MARGIN=1,function(x){x/sum(x)})) # rescale so that each row sums to 1
# Replace original matrix with new completed matrix
if(output_type=="prop"){
comp_i <- M_out_i
}else{
# Add sample size column
n_tag_cols <- matrix(NA,ncol=length(n_colname_new),nrow=nrow(M_out_i),dimnames=list(rownames(M_out_i),n_colname_new))
comp_i <- as.data.frame(cbind(n_tag_cols,M_out_i))
RootComp_i <- compName_i
RootComp_n <- gsub(pattern=n_tag[1],replacement="",x=names(comp_data_n))
Comp_n_i <- comp_data_n[,paste(RootComp_i,n_tag,sep=""),drop=FALSE]
rows_Comp_n_i <- match(rownames(comp_i),rownames(Comp_n_i))
comp_i[,n_colname_new] <- Comp_n_i[rows_Comp_n_i,paste(RootComp_i,n_tag,sep="")]
}
if(output_type=="input"){
comp_i <- comp_i
}
if(output_type=="nfish"){
comp_i <- round(comp_i[,!names(comp_i)%in%n_colname_new]*comp_i$nfish)
}
comp_i[comp_i==valsToNA] <- NA # Change specified values to NA (e.g. -99999)
comp_list[[compName_i]] <- comp_i
}
return(comp_list)
}
cm <- rdat_RedPorgy$comp.mats
cma <- cm[grepl("^acomp.*ob$",names(cm))]
cmanfish <- rdat_RedPorgy$t.series[,gsub("ob$","nfish",names(cma))]
comp_complete(cma,output_type="prop")
comp_complete(cma,cmanfish,output_type="nfish")
comp_list=cma;comp_data_n=cmanfish;xBinByDataframe=FALSE
n_tag= c("n","nfish")
n_colname_new= c("ntrip","nfish")
val_rownames=NULL
val_colnames=NULL
output_type="nfish"
minusGroup=FALSE
plusGroup=FALSE
valsToNA=-99999
rownames_all <- sort(unique(unlist(lapply(comp_list,rownames))))
colnames_all <- paste(sort(as.numeric(unique(unlist(lapply(comp_list,colnames))))))
if(is.null(val_rownames)){
val_rownames <- paste(min(as.numeric(rownames_all)):max(as.numeric(rownames_all)))
}
if(is.null(val_colnames)){
val_colnames <- colnames_all
}
compName_i
M_i <- comp_list[[compName_i]]
colnames_obs_i <- colnames(M_i)
if(xBinByDataframe){
val_colnames_i <- colnames(M_i)
}else{
val_colnames_i <- val_colnames
}
# Identify the specific row and column names missing comp matrix i
row_missing <- val_rownames[!val_rownames%in%rownames(M_i)]
col_missing <- val_colnames_i[!val_colnames_i%in%colnames(M_i)]
## Add missing rows
# Create empty matrix of missing rows
M_row_missing <- matrix(NA,nrow=length(row_missing),ncol=ncol(M_i),dimnames=list(row_missing,colnames(M_i)))
# Actually add missing rows and columns to comp matrix i
M_i2 <- rbind(M_i,M_row_missing)
M_i2 <- local({M_i2 %>% rownames %>% order -> o; M_i2[o,]}) # Sort rows of M_i2
## Add missing columns
# Create empty matrix of missing columns
M_col_missing <- matrix(NA,nrow=nrow(M_i2),ncol=length(col_missing),dimnames=list(row.names(M_i2),col_missing))
# Actually add missing rows and columns to comp matrix i
M_i3 <- cbind(M_i2,M_col_missing)
M_i3 <- local({M_i3 %>% colnames %>% as.numeric %>% order -> o; M_i3[,o]}) # Sort columns of M_i3
# Add minus group if specified, and if data are going to be truncated
# (by default, function simply excludes values below minimum val_colnames_i)
if(minusGroup&min(as.numeric(val_colnames_i))>min(as.numeric(colnames_obs_i))){
M_i3_minus <- M_i3[,as.numeric(colnames_obs_i) <= min(as.numeric(val_colnames_i)),drop=FALSE]
M_i3[,paste(min(as.numeric(val_colnames_i)))] <-  rowSums(M_i3_minus) # Add plus group values
M_i3[which(!is.na(rowSums(M_i3))),which(as.numeric(colnames_obs_i) < min(as.numeric(val_colnames_i)))] <- 0 # Replace values in bins above with zeros
}
# Add plus group if specified, and if data are going to be truncated
# (by default, function simply excludes values above maximum val_colnames_i)
if(plusGroup&max(as.numeric(val_colnames_i))<max(as.numeric(colnames_obs_i))){
M_i3_plus <- M_i3[,as.numeric(colnames_obs_i) >= max(as.numeric(val_colnames_i)),drop=FALSE]
M_i3[,paste(max(as.numeric(val_colnames_i)))] <-  rowSums(M_i3_plus) # Add plus group values
M_i3[which(!is.na(rowSums(M_i3))),which(as.numeric(colnames_obs_i) > max(as.numeric(val_colnames_i)))] <- 0 # Replace values in bins above with zeros
}
# Replace NA in rows (years) with data with zeros
M_i3 <- t(apply(M_i3, 1, function(x){
if(all(is.na(x))){
x}else{
x[is.na(x)] <- 0
x
}
}))
M_out_i <- matrix(NA,nrow=length(val_rownames),ncol=length(val_colnames_i),dimnames=list(val_rownames,val_colnames_i))
# Add observed values to the appropriate cells in the output matrix
for(obs_rowName_j in rownames(M_i3)[which(rownames(M_i3)%in%rownames(M_out_i))]){
obs_colname_i <- colnames(M_i3)[which(colnames(M_i3)%in%colnames(M_out_i))]
#M_out_i[obs_rowName_j,] <- rep(0,ncol(M_out_i)) # First fill with zeros
# Linear interpolation to match val_colnames_i (won't change anything if existing column names are desired)
x_ij <- M_i3[obs_rowName_j,]
y_ij <- rep(NA,length(val_colnames_i))
if(any(!is.na(x_ij))){
y_ij <- approx(as.numeric(names(x_ij)),x_ij,xout = as.numeric(val_colnames_i))$y
}
M_out_i[obs_rowName_j,] <- y_ij # Now fill with observed data
}
M_out_i <- t(apply(M_out_i,MARGIN=1,function(x){x/sum(x)})) # rescale so that each row sums to 1
# Replace original matrix with new completed matrix
(output_type=="prop")
n_tag_cols <- matrix(NA,ncol=length(n_colname_new),nrow=nrow(M_out_i),dimnames=list(rownames(M_out_i),n_colname_new))
comp_i <- as.data.frame(cbind(n_tag_cols,M_out_i))
RootComp_i <- compName_i
RootComp_n <- gsub(pattern=n_tag[1],replacement="",x=names(comp_data_n))
RootComp_n
n_tag[1]
names(comp_data_n)
n_tag
n_tag <- "nfish"
n_tag_cols <- matrix(NA,ncol=length(n_colname_new),nrow=nrow(M_out_i),dimnames=list(rownames(M_out_i),n_colname_new))
comp_i <- as.data.frame(cbind(n_tag_cols,M_out_i))
RootComp_i <- compName_i
RootComp_n <- gsub(pattern=n_tag[1],replacement="",x=names(comp_data_n))
Comp_n_i <- comp_data_n[,paste(RootComp_i,n_tag,sep=""),drop=FALSE]
rows_Comp_n_i <- match(rownames(comp_i),rownames(Comp_n_i))
comp_i[,n_colname_new] <- Comp_n_i[rows_Comp_n_i,paste(RootComp_i,n_tag,sep="")]
RootComp_n
n_tag <- ".nfish"
n_tag_cols <- matrix(NA,ncol=length(n_colname_new),nrow=nrow(M_out_i),dimnames=list(rownames(M_out_i),n_colname_new))
comp_i <- as.data.frame(cbind(n_tag_cols,M_out_i))
RootComp_i <- compName_i
RootComp_n <- gsub(pattern=n_tag[1],replacement="",x=names(comp_data_n))
Comp_n_i <- comp_data_n[,paste(RootComp_i,n_tag,sep=""),drop=FALSE]
rows_Comp_n_i <- match(rownames(comp_i),rownames(Comp_n_i))
comp_i[,n_colname_new] <- Comp_n_i[rows_Comp_n_i,paste(RootComp_i,n_tag,sep="")]
RootComp_n
comp_data_n[,paste(RootComp_i,n_tag,sep=""),drop=FALSE]
comp_data_n
paste(RootComp_i,n_tag,sep="")
RootComp_i
names(cmanfish)
names(cma)
gsub(".ob$","",names(cma))
names(cma) <- gsub(".ob$","",names(cma))
comp_complete(cma,output_type="prop")
comp_complete(cma,cmanfish,output_type="nfish")
comp_complete <- function(comp_list,comp_data_n,xBinByDataframe=FALSE,
n_tag= c(".n",".nfish"),
n_colname_new= c("ntrip","nfish"),
val_rownames=NULL,
val_colnames=NULL,
output_type="prop",
minusGroup=FALSE,
plusGroup=FALSE,
valsToNA=-99999){
rownames_all <- sort(unique(unlist(lapply(comp_list,rownames))))
colnames_all <- paste(sort(as.numeric(unique(unlist(lapply(comp_list,colnames))))))
if(is.null(val_rownames)){
val_rownames <- paste(min(as.numeric(rownames_all)):max(as.numeric(rownames_all)))
}
if(is.null(val_colnames)){
val_colnames <- colnames_all
}
for (compName_i in names(comp_list)){
M_i <- comp_list[[compName_i]]
colnames_obs_i <- colnames(M_i)
if(xBinByDataframe){
val_colnames_i <- colnames(M_i)
}else{
val_colnames_i <- val_colnames
}
# Identify the specific row and column names missing comp matrix i
row_missing <- val_rownames[!val_rownames%in%rownames(M_i)]
col_missing <- val_colnames_i[!val_colnames_i%in%colnames(M_i)]
## Add missing rows
# Create empty matrix of missing rows
M_row_missing <- matrix(NA,nrow=length(row_missing),ncol=ncol(M_i),dimnames=list(row_missing,colnames(M_i)))
# Actually add missing rows and columns to comp matrix i
M_i2 <- rbind(M_i,M_row_missing)
M_i2 <- local({M_i2 %>% rownames %>% order -> o; M_i2[o,]}) # Sort rows of M_i2
## Add missing columns
# Create empty matrix of missing columns
M_col_missing <- matrix(NA,nrow=nrow(M_i2),ncol=length(col_missing),dimnames=list(row.names(M_i2),col_missing))
# Actually add missing rows and columns to comp matrix i
M_i3 <- cbind(M_i2,M_col_missing)
M_i3 <- local({M_i3 %>% colnames %>% as.numeric %>% order -> o; M_i3[,o]}) # Sort columns of M_i3
# Add minus group if specified, and if data are going to be truncated
# (by default, function simply excludes values below minimum val_colnames_i)
if(minusGroup&min(as.numeric(val_colnames_i))>min(as.numeric(colnames_obs_i))){
M_i3_minus <- M_i3[,as.numeric(colnames_obs_i) <= min(as.numeric(val_colnames_i)),drop=FALSE]
M_i3[,paste(min(as.numeric(val_colnames_i)))] <-  rowSums(M_i3_minus) # Add plus group values
M_i3[which(!is.na(rowSums(M_i3))),which(as.numeric(colnames_obs_i) < min(as.numeric(val_colnames_i)))] <- 0 # Replace values in bins above with zeros
}
# Add plus group if specified, and if data are going to be truncated
# (by default, function simply excludes values above maximum val_colnames_i)
if(plusGroup&max(as.numeric(val_colnames_i))<max(as.numeric(colnames_obs_i))){
M_i3_plus <- M_i3[,as.numeric(colnames_obs_i) >= max(as.numeric(val_colnames_i)),drop=FALSE]
M_i3[,paste(max(as.numeric(val_colnames_i)))] <-  rowSums(M_i3_plus) # Add plus group values
M_i3[which(!is.na(rowSums(M_i3))),which(as.numeric(colnames_obs_i) > max(as.numeric(val_colnames_i)))] <- 0 # Replace values in bins above with zeros
}
# Replace NA in rows (years) with data with zeros
M_i3 <- t(apply(M_i3, 1, function(x){
if(all(is.na(x))){
x}else{
x[is.na(x)] <- 0
x
}
}))
M_out_i <- matrix(NA,nrow=length(val_rownames),ncol=length(val_colnames_i),dimnames=list(val_rownames,val_colnames_i))
# Add observed values to the appropriate cells in the output matrix
for(obs_rowName_j in rownames(M_i3)[which(rownames(M_i3)%in%rownames(M_out_i))]){
obs_colname_i <- colnames(M_i3)[which(colnames(M_i3)%in%colnames(M_out_i))]
#M_out_i[obs_rowName_j,] <- rep(0,ncol(M_out_i)) # First fill with zeros
# Linear interpolation to match val_colnames_i (won't change anything if existing column names are desired)
x_ij <- M_i3[obs_rowName_j,]
y_ij <- rep(NA,length(val_colnames_i))
if(any(!is.na(x_ij))){
y_ij <- approx(as.numeric(names(x_ij)),x_ij,xout = as.numeric(val_colnames_i))$y
}
M_out_i[obs_rowName_j,] <- y_ij # Now fill with observed data
}
M_out_i <- t(apply(M_out_i,MARGIN=1,function(x){x/sum(x)})) # rescale so that each row sums to 1
# Replace original matrix with new completed matrix
if(output_type=="prop"){
comp_i <- M_out_i
}else{
# Add sample size column
n_tag_cols <- matrix(NA,ncol=length(n_colname_new),nrow=nrow(M_out_i),dimnames=list(rownames(M_out_i),n_colname_new))
comp_i <- as.data.frame(cbind(n_tag_cols,M_out_i))
RootComp_i <- compName_i
RootComp_n <- gsub(pattern=n_tag[1],replacement="",x=names(comp_data_n))
Comp_n_i <- comp_data_n[,paste(RootComp_i,n_tag,sep=""),drop=FALSE]
rows_Comp_n_i <- match(rownames(comp_i),rownames(Comp_n_i))
comp_i[,n_colname_new] <- Comp_n_i[rows_Comp_n_i,paste(RootComp_i,n_tag,sep="")]
}
if(output_type=="input"){
comp_i <- comp_i
}
if(output_type=="nfish"){
comp_i <- round(comp_i[,!names(comp_i)%in%n_colname_new]*comp_i$nfish)
}
comp_i[comp_i==valsToNA] <- NA # Change specified values to NA (e.g. -99999)
comp_list[[compName_i]] <- comp_i
}
return(comp_list)
}
comp_complete(cma,cmanfish,output_type="nfish")
comp_list=cma;comp_data_n=cmanfish;xBinByDataframe=FALSE
n_tag= c(".nfish")
n_colname_new= c("ntrip","nfish")
val_rownames=NULL
val_colnames=NULL
output_type="nfish"
minusGroup=FALSE
plusGroup=FALSE
valsToNA=-99999
comp_complete(cma,cmanfish,output_type="nfish",n_tag=".nfish")
comp_complete(cma,cmanfish,output_type="nfish",n_tag=".nfish")
cm <- rdat_RedPorgy$comp.mats
cma <- cm[grepl("^acomp.*ob$",names(cm))]
cmanfish <- rdat_RedPorgy$t.series[,gsub("ob$","nfish",names(cma))]
comp_complete(cma,output_type="prop")
names(cma) <- gsub(".ob$","",names(cma))
comp_complete(cma,cmanfish,output_type="nfish",n_tag=".nfish")
gsub("ob$","nfish",names(cma))
c(gsub("ob$","n",names(cma)),gsub("ob$","nfish",names(cma)))
cm <- rdat_RedPorgy$comp.mats
cma <- cm[grepl("^acomp.*ob$",names(cm))]
names(cma) <- gsub(".ob$","",names(cma))
cmanfish <- rdat_RedPorgy$t.series[,gsub("ob$","nfish",names(cma))]
# Output proportions at age
comp_complete(cma,output_type="prop")
# Output numbers of fish at age
comp_complete(cma,cmanfish,output_type="nfish",n_tag=".nfish")
cm <- rdat_RedPorgy$comp.mats
cma <- cm[grepl("^acomp.*ob$",names(cm))]
cmanfish <- rdat_RedPorgy$t.series[,gsub("ob$","nfish",names(cma))]
# Output proportions at age
comp_complete(cma,output_type="prop")
names(cma) <- gsub(".ob$","",names(cma))
comp_complete(cma,cmanfish,output_type="nfish",n_tag=".nfish")
# Output age comps in data input format
cma <- cm[grepl("^acomp.*ob$",names(cm))]
names(cmp)
names(cma)
gsub("ob$","nfish",names(cma))
gsub("ob$","n",names(cma))
c(gsub("ob$","n",names(cma)),gsub("ob$","nfish",names(cma)))
cman <- rdat_RedPorgy$t.series[,gsub("ob$","n",names(cma))]
cmanfish <- rdat_RedPorgy$t.series[,gsub("ob$","nfish",names(cma))]
# Output age comps in data input format
comp_complete(cma,cbind(cman,cmanfish),output_type="input")
str(cma)
cm <- rdat_RedPorgy$comp.mats
cma <- cm[grepl("^acomp.*ob$",names(cm))]
cman <- rdat_RedPorgy$t.series[,gsub("ob$","n",names(cma))]
cmanfish <- rdat_RedPorgy$t.series[,gsub("ob$","nfish",names(cma))]
# Output proportions at age
comp_complete(cma,output_type="prop")
# Output numbers of fish at age
names(cma) <- gsub(".ob$","",names(cma))
comp_complete(cma,cmanfish,output_type="nfish",n_tag=".nfish")
# Output age comps in data input format
comp_complete(cma,cbind(cman,cmanfish),output_type="input")
month.name
standardize_rdat()
View(standardize_rdat)
find_replace(c("R0","M.msst","M.MSST"),c("BH.R0","M.constant","M.constant"),names(rdat_BlackSeaBass$parms))
rdat_BlackSeaBass$parms
unlist(rdat_BlackSeaBass$parms)
names(rdat_BlackSeaBass$parms)
find_replace(c("R0","M.msst","M.MSST"),c("BH.R0","M.constant","M.constant"),names(rdat_BlackSeaBass$parms))
rdat <- rdat_BlackSeaBass
parms <- rdat$parms
parms_names <- names(parms)
parms_key <- c("R0"="BH.R0", "M.msst"="M.constant", "M.MSST"="M.constant")
find_replace(names(parms_key),parms_key,parms_names)
source("~/GitHub/myPackages/bamExtras/R/standardize_bam.r", echo=TRUE)
out <- standardize_bam("RedPorgy")
str(out)
source("~/GitHub/myPackages/bamExtras/R/standardize_bam.r", echo=TRUE)
bam_AtMe <- standardize_bam("AtlanticMenhaden")
bam_BlSB <- standardize_bam("BlackSeaBass")
library(bamExtras)
?standardize_bam
bam_AtMe <- standardize_bam("AtlanticMenhaden")
bam_BlSB <- standardize_bam("BlackSeaBass")
bam_BlTi <- standardize_bam("BluelineTilefish")
bam_Cobi <- standardize_bam("Cobia")
bam_GagG <- standardize_bam("GagGrouper")
bam_GrTr <- standardize_bam("GrayTriggerfish")
bam_GrAm <- standardize_bam("GreaterAmberjack")
bam_ReGr <- standardize_bam("RedGrouper")
bam_RePo <- standardize_bam("RedPorgy")
bam_ReSn <- standardize_bam("RedSnapper")
bam_SnGr <- standardize_bam("SnowyGrouper")
bam_Tile <- standardize_bam("Tilefish")
bam_VeSn <- standardize_bam("VermilionSnapper")
rdat_out <- run_bam(bam=bam_AtMe,fileName="AtMe")
rdat_out <- run_bam(bam=bam_BlSB,fileName="BlSB")
rdat_out <- run_bam(bam=bam_BlTi,fileName="BlTi")
rdat_out <- run_bam(bam=bam_Cobi,fileName="Cobi")
rdat_out <- run_bam(bam=bam_GagG,fileName="GagG")
rdat_out <- run_bam(bam=bam_GrTr,fileName="GrTr")
rdat_out <- run_bam(bam=bam_GrAm,fileName="GrAm")
getwd()
names(bam_GrAm$L_init)
setwd("~/GitHub/myPackages/bamExtras")
setwd("~/GitHub/myPackages/bamExtras/R")
bam_GrAm <- bam2r("GreaterAmberjack")
tmp <- run_bam(bam=bam_GrAm,fileName="GrAm")
str(bam_GrAm)
names(bam_GrAm)
bam_GrAm$L_init
library(bamExtras)
?bam2r
bam_AtMe <- standardize_bam("AtlanticMenhaden")
bam_BlSB <- standardize_bam("BlackSeaBass")
bam_BlTi <- standardize_bam("BluelineTilefish")
bam_Cobi <- standardize_bam("Cobia")
bam_GagG <- standardize_bam("GagGrouper")
bam_GrTr <- standardize_bam("GrayTriggerfish")
bam_GrAm <- standardize_bam("GreaterAmberjack")
bam_ReGr <- standardize_bam("RedGrouper")
bam_RePo <- standardize_bam("RedPorgy")
bam_ReSn <- standardize_bam("RedSnapper")
bam_SnGr <- standardize_bam("SnowyGrouper")
bam_Tile <- standardize_bam("Tilefish")
bam_VeSn <- standardize_bam("VermilionSnapper")
rdat_out<- run_bam(bam=bam_GrAm,fileName="GrAm")
rdat_out<- run_bam(bam=bam_ReGr,fileName="ReGr")
rdat_out<- run_bam(bam=bam_RePo,fileName="RePo")
rdat_out<- run_bam(bam=bam_ReSn,fileName="ReSn")
?runMSe
?runMSE
library(openMSE)
?runMSE
library(bamExtras)
ts
tser
tser <- rdat_BlackSeaBass$t.series
names(tser)
grepl("^U.*ob$",,names(tser)
grepl("^U.*ob$",names(tser)
)
grepl("^U.*ob$",names(tser))
names(tser)[grepl("^U.*ob$",names(tser))]
U <- tser[,grepl("^U.*ob$",names(tser))]
U
names(tser)
tser[,grepl("^cv.U.*ob$",names(tser))]
tser[,grepl("^cv.U.",names(tser))]
Ucv <- tser[,grepl("^cv.U.",names(tser))]
U <- tser[,grepl("^U.*ob$",names(tser))]
tseries_plot(U,Ucv)
tseries_plot(U,Ucv,xlab="year",ylab="index of abundance")
source("~/GitHub/myPackages/bamExtras/R/tseries_plot.r", echo=TRUE)
tseries_plot(U,Ucv,xlab="year",ylab="index of abundance")
source("~/GitHub/myPackages/bamExtras/R/tseries_plot.r", echo=TRUE)
tseries_plot(U,Ucv,xlab="year",ylab="index of abundance")
rdat <- rdat_BlackSeaBass
rdat$info$species
tseries_plot(U,Ucv,xlab="year",ylab="index of abundance",plotLabel=rdat$info$species)
rdat$info$title
plotLabel <- paste0(rdat$info$title,": ",rdat$info$species)
tseries_plot(U,Ucv,xlab="year",ylab="index of abundance",plotLabel=plotLabel)
source("~/GitHub/myPackages/bamExtras/R/tseries_plot.r", echo=TRUE)
vb_len(a=0:11,Linf = 502, K = 0.173, t0 = -0.97)
len <- vb_len(a=0:11,Linf = 502, K = 0.173, t0 = -0.97)
vb_age(L=len,Linf = 502, K = 0.173, t0 = -0.97)
len <- vb_len(a=0:11,Linf = 502, K = 0.173, t0 = 0)
vb_age(L=len,Linf = 502, K = 0.173, t0 = -0.97)
vb_age(L=len,Linf = 502, K = 0.173, t0 = 0)
str(rdat$parm.cons)
rdat$parm.cons[8,]
parest <- rdat$parm.cons[8,]
tser <- rdat$t.series
aser <- rdat$a.series
aser$age
aser$length
with(parest,{
with(parest,{vb_len(a=age,Linf=Linf,K=K,t0=t0)})
with(parest,{vb_len(a=age,Linf=Linf,K=K,t0=t0)})
age <- aser$age
with(parest,{vb_len(a=age,Linf=Linf,K=K,t0=t0)})
with(parest,{vb_age(a=len,Linf=Linf,K=K,t0=t0)})
with(parest,{vb_age(L=len,Linf=Linf,K=K,t0=t0)})
with(parest,{vb_age(L=len,Linf=Linf,K=K,t0=0)})
len_out <- with(parest,{vb_len(a=age,Linf=Linf,K=K,t0=t0)})
with(parest,{vb_age(L=len_out,Linf=Linf,K=K,t0=0)})
len_out
len
with(parest,{vb_age(L=len_out,Linf=Linf,K=K,t0=t0)})
with(parest,{vb_age(L=len_out,Linf=Linf,K=K,t0=0)})
with(parest,{vb_age(L=with(parest,{vb_len(a=age,Linf=Linf,K=K,t0=0)}),Linf=Linf,K=K,t0=0)})
library(bamExtras)
browseVignettes("bamExtras")
