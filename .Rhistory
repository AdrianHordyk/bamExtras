names(init_endyr))
# # Make sure endyr_rec values aren't larger than endyr_rec_dev
# init_endyr_i[grepl("endyr_rec",names(init_endyr_i))] <-
#   lapply(init_endyr_i[grepl("endyr_rec",names(init_endyr_i))],function(x){paste(min(init_endyr_i$endyr_rec_dev,as.numeric(x)))})
# yrs values
init_yrs_i <- lapply(init_yrs,function(x){
x[which(x<=endyr_i)]
})
# nyr values
init_nyr_i <- init_nyr # initialize
for(j in seq_along(init_nyr)){
nyr_nm_j <- names(init_nyr)[j]
init_nyr_i[[j]] <- paste(length(init_yrs_i[[gsub("^nyr","yrs",names(init_nyr)[j])]]))
}
# obs values
init_obs_i <- lapply(init_obs,function(x){
if(is.vector(x)){
y <- as.numeric(names(x))
# If the names are years within the model data range..
if(all(y%in%init_styr_i$styr:endyr_i)){
x[which(y<=endyr_i)] # ..truncate the object to the desired set of years
}else{ # ..otherwise do nothing because the object doesn't have a time dimension
x
}
}else if(is.matrix(x)){
y <- as.numeric(rownames(x))
x[paste(y)[which(y<=endyr_i)],,drop=FALSE]
}else{
warning("element x in init_obs_i is neither a vector nor a matrix")
}
})
# set_log_dev_vals values
init_set_log_dev_vals_i <- setNames(lapply(seq_along(init_set_log_dev_vals),function(j){
name_j <- names(init_set_log_dev_vals)[j]
x <- init_set_log_dev_vals[[j]]
y <- as.numeric(names(x))
if(name_j=="set_log_dev_vals_rec"){
x[which(y<=init_endyr_i$endyr_rec_dev)]
}else{
x[which(y<=endyr_i)]
}
}),
names(init_set_log_dev_vals)
)
# nsamp values
init_nsamp_i <- lapply(init_nsamp,function(x){
y <- as.numeric(names(x))
x[which(y<=endyr_i)]
})
# nfish values
init_nfish_i <- lapply(init_nfish,function(x){
y <- as.numeric(names(x))
x[which(y<=endyr_i)]
})
#### Add trimmed temporal objects back into init_i
init_i[names(init_styr_i)] <- init_styr_i
init_i[names(init_endyr_i)] <- init_endyr_i
init_i[names(init_yrs_i)] <- init_yrs_i
init_i[names(init_nyr_i)] <- init_nyr_i
init_i[names(init_obs_i)] <- init_obs_i
init_i[names(init_set_log_dev_vals_i)] <- init_set_log_dev_vals_i
init_i[names(init_nsamp_i)] <- init_nsamp_i
init_i[names(init_nfish_i)] <- init_nfish_i
inits[[i]] <- init_i
}
names(inits) <- names(endyr_sim)
### Identify temporal objects in init
# styr
init_styr <- init[grepl("^styr",names(init))]
# endyr
init_endyr <- init[grepl("^endyr",names(init))]
# nyr
init_nyr <- init[grepl("^nyr",names(init))]
# yrs
init_yrs <- init[grepl("^yrs",names(init))]
# obs
init_obs <- init[grepl("^obs_(cpue|L|cv|released|lenc|agec|maturity)",names(init))]
# tv (time varying objects currently in Atlantic Menhaden model)
init_tv <- init[grepl("_tv$",names(init))]
# set_log_dev_vals (not Nage)
init_set_log_dev_vals <- init[grepl("^set_log_dev_vals(?!.*(Nage))",names(init),perl=TRUE)]
# nsamp
init_nsamp <- init[grepl("^nsamp",names(init))]
# nfish
init_nfish <- init[grepl("^nfish",names(init))]
# For each value in endyr_sim..
for(i in seq_along(endyr_sim)){
init_i <- init
endyr_i <- endyr_sim[i]
nyr_remove_i <- nyr_remove[i]
#### Trim temporal objects
# styr values
# (few styr values will be affected other than styr_regs which is used in the projection code)
init_styr_i <- lapply(init_styr,function(x){
if(as.numeric(x)>endyr_i){
paste(as.numeric(x)-nyr_remove_i)
}else{
paste(x)
}
})
# endyr values
init_endyr_i <- setNames(lapply(seq_along(init_endyr),function(j){
x <- init_endyr[j]
xd <- as.numeric(x)-as.numeric(endyr_i)
# For endyr, endyr_rec_, or endyr_proj values, always reduce the values by nyr_remove_i
if(grepl("^endyr$|^endyr_rec_(?!.*(phase1))|endyr_proj",names(init_endyr[j]),perl=TRUE)){
paste(as.numeric(x)-nyr_remove_i) # Reduce it by nyr_remove_i
# or if the current _endyr value is greater than the new endyr_i..
}else if(as.numeric(x)>endyr_i){
as.character(as.numeric(endyr_i)) # Set it equal to endyr_i
}else{
paste(x)
}
}),
names(init_endyr))
# # Make sure endyr_rec values aren't larger than endyr_rec_dev
# init_endyr_i[grepl("endyr_rec",names(init_endyr_i))] <-
#   lapply(init_endyr_i[grepl("endyr_rec",names(init_endyr_i))],function(x){paste(min(init_endyr_i$endyr_rec_dev,as.numeric(x)))})
# yrs values
init_yrs_i <- lapply(init_yrs,function(x){
x[which(x<=endyr_i)]
})
# nyr values
init_nyr_i <- init_nyr # initialize
for(j in seq_along(init_nyr)){
nyr_nm_j <- names(init_nyr)[j]
init_nyr_i[[j]] <- paste(length(init_yrs_i[[gsub("^nyr","yrs",names(init_nyr)[j])]]))
}
# obs values
init_obs_i <- lapply(init_obs,function(x){
if(is.vector(x)){
y <- as.numeric(names(x))
# If the names are years within the model data range..
if(all(y%in%init_styr_i$styr:endyr_i)){
x[which(y<=endyr_i)] # ..truncate the object to the desired set of years
}else{ # ..otherwise do nothing because the object doesn't have a time dimension
x
}
}else if(is.matrix(x)){
y <- as.numeric(rownames(x))
x[paste(y)[which(y<=endyr_i)],,drop=FALSE]
}else{
warning("element x in init_obs_i is neither a vector nor a matrix")
}
})
# set_log_dev_vals values
init_set_log_dev_vals_i <- setNames(lapply(seq_along(init_set_log_dev_vals),function(j){
name_j <- names(init_set_log_dev_vals)[j]
x <- init_set_log_dev_vals[[j]]
y <- as.numeric(names(x))
if(name_j=="set_log_dev_vals_rec"){
x[which(y<=init_endyr_i$endyr_rec_dev)]
}else{
x[which(y<=endyr_i)]
}
}),
names(init_set_log_dev_vals)
)
# nsamp values
init_nsamp_i <- lapply(init_nsamp,function(x){
y <- as.numeric(names(x))
x[which(y<=endyr_i)]
})
# nfish values
init_nfish_i <- lapply(init_nfish,function(x){
y <- as.numeric(names(x))
x[which(y<=endyr_i)]
})
#### Add trimmed temporal objects back into init_i
init_i[names(init_styr_i)] <- init_styr_i
init_i[names(init_endyr_i)] <- init_endyr_i
init_i[names(init_yrs_i)] <- init_yrs_i
init_i[names(init_nyr_i)] <- init_nyr_i
init_i[names(init_obs_i)] <- init_obs_i
init_i[names(init_set_log_dev_vals_i)] <- init_set_log_dev_vals_i
init_i[names(init_nsamp_i)] <- init_nsamp_i
init_i[names(init_nfish_i)] <- init_nfish_i
inits[[i]] <- init_i
}
names(inits) <- names(endyr_sim)
init$obs_agec_sBT
init_i$obs_agec_sBT
if(dir.exists(dir_bam_sim)){
if(prompt_me){
delete_files <- readline(prompt=paste0(paste("The folder",paste0("'",dir_bam_sim,"'"),"already exists. "),"Are you sure you want to delete all files in ",dir_bam_sim,"? (Enter TRUE or FALSE)"))
}else{
delete_files <- TRUE
}
if(delete_files){
unlink(paste0(dir_bam_sim,"/*"))
message(paste("The contents of the folder",paste0("'",dir_bam_sim,"'"),"have been deleted."))
if(dir.exists(dir_bam_sim_fail)){
unlink(paste0(dir_bam_sim_fail,"/*"))
message(paste("The contents of the folder",paste0("'",dir_bam_sim_fail,"'"),"have been deleted."))
}
if(length(list.files(dir_bam_sim))>0){
stop(paste("The contents of the folder",paste0("'",dir_bam_sim,"'"),"were NOT actually deleted."))
}
}else{
message(paste("If you do not want to delete the contents of ",dir_bam_sim,", please specify a new value of dir_bam_sim and rerun."))
}
}else{
dir.create(dir_bam_sim)
message(paste("Created the folder",paste0("'",dir_bam_sim,"'.")))
}
message(paste("Running retrospective analysis for", nsim,"sims in parallel on",coresUse,"cores at",Sys.time()))
getwd()
setwd("~/GitHub/myPackages/bamExtras/TEST_FOLDER/run_retro")
i <- 1
if(dir.exists(dir_bam_sim)){
if(prompt_me){
delete_files <- readline(prompt=paste0(paste("The folder",paste0("'",dir_bam_sim,"'"),"already exists. "),"Are you sure you want to delete all files in ",dir_bam_sim,"? (Enter TRUE or FALSE)"))
}else{
delete_files <- TRUE
}
if(delete_files){
unlink(paste0(dir_bam_sim,"/*"))
message(paste("The contents of the folder",paste0("'",dir_bam_sim,"'"),"have been deleted."))
if(dir.exists(dir_bam_sim_fail)){
unlink(paste0(dir_bam_sim_fail,"/*"))
message(paste("The contents of the folder",paste0("'",dir_bam_sim_fail,"'"),"have been deleted."))
}
if(length(list.files(dir_bam_sim))>0){
stop(paste("The contents of the folder",paste0("'",dir_bam_sim,"'"),"were NOT actually deleted."))
}
}else{
message(paste("If you do not want to delete the contents of ",dir_bam_sim,", please specify a new value of dir_bam_sim and rerun."))
}
}else{
dir.create(dir_bam_sim)
message(paste("Created the folder",paste0("'",dir_bam_sim,"'.")))
}
message(paste("Running retrospective analysis for", nsim,"sims in parallel on",coresUse,"cores at",Sys.time()))
nm_sim_i <- nm_sim[i]
init_i <- inits[[nm_sim_i]]
#%% Incorporate changes to init_i back into BAM dat %%#
bam_i <- bam2r(
dat_obj = dat,
tpl_obj = tpl,
cxx_obj = cxx,
init = init_i)
#%%  File management stuff
sim_dir_i <- paste0("sim_",nm_sim_i)
dir.create(sim_dir_i)
setwd(sim_dir_i)
fileName_exe_base <- paste0(fileName,".exe")
fileName_dat_i <- paste(nm_sim_i,'-',fileName,'.dat',sep="") # Name of dat file for i
fileName_rdat_i <- paste(nm_sim_i,'-',fileName,'.rdat',sep="") # Name of rdat file for i
fileName_exe_i <- paste(nm_sim_i,'-',fileName,'.exe',sep="") # Name of exe file for i
fileName_par_i <- paste(nm_sim_i,'-',fileName,'.par',sep="") # Name of par file for i
# Copy executable to directory for sim i
file.copy(file.path("..",dir_bam_base,fileName_exe_base), fileName_exe_i, overwrite=TRUE)
# Rewrite dat file incorporating modified data
writeLines(text=bam_i$dat, con=fileName_dat_i)
#######Run bam for sim_i
shell(paste(fileName_exe_i, admb_switch_sim, fileName_dat_i, sep=" "))
bam_i2 <- bam2r(
dat_obj = bam_i$dat,
tpl_obj = bam_i$tpl,
cxx_obj = bam_i$cxx)
View(bam_i$dat)
View(bam_i$tpl)
bam_i$tpl
View(init)
View(init_i)
library(bamExtras)
setwd("~/SEDAR/BAM_DATA/MostRecentAssessment/BAMBaseModels/BlackSeaBassSEDAR56.S56-15/base/modified")
# Chunk 1
######
## This script aims to morph the generic version of the previous model into a model for a new assessment.
# Chunk 2: global_options
options(java.parameters = "-Xmx1g")  # Increase the amount of memory available to Java
library(bamExtras)
library(Hmisc)
library(knitr)
# library(magrittr) # For enabling pipe operators
library(stringr)
library(zoo) # For moving averages
opts_chunk$set(comment=NA,echo=FALSE,message=FALSE,warning=FALSE,fig.height=6,fig.width=6)
# Chunk 3: admin
rm(list=ls())
runName <- "BaseRun"
#dRoot <- "C:/Users/Nikolai.Klibansky/Documents/SEDAR/SEDAR_66/Assessment/ADMB"
# Name working directory for scripts
wd <- getwd()
# ADMB file directory
dADMB <- paste(wd,"ADMBFiles",sep="/")
# Names you want to use for current assessment files
SpedatName <-  "BAMBase.dat"
SpetplName <-  "BAMBase.tpl"
SpecxxName <-  "BAMBase.cxx"
SperdatName <- "BAMBase.rdat"
SpeRootName <- gsub(".dat","",SpedatName)
#switches applied during admb execution, list with space in between
admb.switch='-nox' # '-est -nox'
# Header options ("update" if existing and formatted correctly or "add" if not)
header <- "add"
# Chunk 4: BAMInputHeader
Author <- "NMFS, Beaufort Lab, Sustainable Fisheries Branch"
Analyst <- "Kate Siegfried"
Species <- "Black Sea Bass"
Region <- "US South Atlantic"
SEDAR <- "56"
Date <- Sys.time()
# Chunk 5: loadRData
load("_04_BAM_MakeTPLGeneric.RData")
# Chunk 6: user pattern replace
# Specify patterns and replacements to apply only to the r object names in cxx file (does not affect the ADMB object names in the cxx file). These are applied in order!!
# NOTES: names are patterns, values are the replacements
# The substitution is done very conservatively so there is little chance of accidentally changing parts of the cxx.
patrep <- c(
"cLcP" = "cL.cP", # Clarify separation between these two fleets cL and cP
"cL"="cH",         # Change abbreviation for commercial lines to commercial handlines
"_"="\\."         # Change separators from "_" to "."
)
# Chunk 7: RunBAMToR1
# Retrieve input values from the previous assessment for this species
# L.init.prev <- env.Spe$L.init.Ref
# Current template
bam2r_out <- bam2r(
dat_file = file.path(dADMB,GendatName),
tpl_file = file.path(dADMB,GentplName),
cxx_file = file.path(dADMB,GencxxName)
)
tpl <- bam2r_out$tpl
dat <- bam2r_out$dat
names(dat) <- NULL
cxx <- bam2r_out$cxx
#L.init <- bam2r_out$L.init
# Chunk 8: modifyDat
# Modify header
if(header=="update"){
dat[which(grepl(pattern = "##  Author:",x=dat))]  <- paste("##  Author:",Author)
dat[which(grepl(pattern = "##  Analyst:",x=dat))] <- paste("##  Analyst:",Analyst)
dat[which(grepl(pattern = "##  Species:",x=dat))] <- paste("##  Species:",Species)
dat[which(grepl(pattern = "##  Region:",x=dat))]  <- paste("##  Region:",Region)
dat[which(grepl(pattern = "##  SEDAR:",x=dat))]   <- paste("##  SEDAR:",SEDAR)
dat[which(grepl(pattern = "##  Date:",x=dat))]    <- paste("##  Date:",Date)
}
if(header=="add"){
dat <- c(paste("##  Author:",Author),
paste("##  Analyst:",Analyst),
paste("##  Species:",Species),
paste("##  Region:",Region),
paste("##  SEDAR:",SEDAR),
paste("##  Date:",Date),
"",
"",
dat
)
}
# pattern replacement
# for(i in seq_along(patrep)){
#   dat <- gsub(names(patrep)[i],patrep[i],dat)
# }
# Chunk 9: modifyTpl
tpl <- gsub(x=bam2r_out$tpl,pattern=GencxxName,replacement=SpecxxName)
# Modify header
if(header=="update"){
tpl[which(grepl(pattern = "##  Author:",x=tpl))] <- paste("//##  Author:",Author)
tpl[which(grepl(pattern = "##  Analyst:",x=tpl))] <- paste("//##  Analyst:",Analyst)
tpl[which(grepl(pattern = "##  Species:",x=tpl))] <- paste("//##  Species:",Species)
tpl[which(grepl(pattern = "##  Region:",x=tpl))] <- paste("//##  Region:",Region)
tpl[which(grepl(pattern = "##  SEDAR:",x=tpl))] <- paste("//##  SEDAR:",SEDAR)
tpl[which(grepl(pattern = "##  Date:",x=tpl))] <- paste("//##  Date:",Date)
}
if(header=="add"){
tpl <- c(paste("//##  Author:",Author),
paste("//##  Analyst:",Analyst),
paste("//##  Species:",Species),
paste("//##  Region:",Region),
paste("//##  SEDAR:",SEDAR),
paste("//##  Date:",Date),
"",
"",
tpl
)
}
# pattern replacement
# for(i in seq_along(patrep)){
#   tpl <- gsub(names(patrep)[i],patrep[i],tpl)
# }
# Chunk 10: modifyCxx
cxx <- bam2r_out$cxx
# Modify header
if(header=="update"){
cxx[which(grepl(pattern = "##  Author:",x=cxx))] <- paste("//##  Author:",Author)
cxx[which(grepl(pattern = "##  Analyst:",x=cxx))] <- paste("//##  Analyst:",Analyst)
cxx[which(grepl(pattern = "##  Species:",x=cxx))] <- paste("//##  Species:",Species)
cxx[which(grepl(pattern = "##  Region:",x=cxx))] <- paste("//##  Region:",Region)
cxx[which(grepl(pattern = "##  SEDAR:",x=cxx))] <- paste("//##  SEDAR:",SEDAR)
cxx[which(grepl(pattern = "##  Date:",x=cxx))] <- paste("//##  Date:",Date)
}
if(header=="add"){
cxx <- c(paste("//##  Author:",Author),
paste("//##  Analyst:",Analyst),
paste("//##  Species:",Species),
paste("//##  Region:",Region),
paste("//##  SEDAR:",SEDAR),
paste("//##  Date:",Date),
"",
"",
cxx
)
}
## Apply pattern replacement to r object names in cxx file (does not affect the ADMB object names in the cxx file)
# Identify r object names specified in cxx file
# regexr.com/6g942
cxx.robnam1 <- cxx.robnam2  <- str_extract_all(cxx,'(?<=\\(").[^,]+(?=")')
# Change object names
for(i in seq_along(patrep)){
# gsub patterns inside parentheses and quotes
cxx.robnam2 <- gsub(names(patrep)[i],patrep[i],cxx.robnam2)
}
# Identify lines that have been modified and gsub them in cxx
cxx.lines.mod <- which(cxx.robnam1!=cxx.robnam2)
for(i in cxx.lines.mod){
line.i <- cxx[i]
line.i.new <- sub(cxx.robnam1[i],cxx.robnam2[i],line.i)
cxx[i] <- line.i.new
}
# Chunk 11: writeADMBFiles
writeLines(text=dat, con=paste(dADMB,SpedatName,sep="/"))
writeLines(text=tpl, con=paste(dADMB,SpetplName,sep="/"))
writeLines(text=cxx, con=paste(dADMB,SpecxxName,sep="/"))
# Chunk 12: runADMBToTest
# Change name of cxx file run by tpl
####### Compile ADMB code
setwd(dADMB)
filename <- gsub(SpetplName,pattern=".tpl",replacement="")
filename.dat <- paste(filename,"dat",sep=".")
filename.tpl <- paste(filename,"tpl",sep=".")
filename.cxx <- paste(filename,"cxx",sep=".")
filename.rdat <- paste(filename,"rdat",sep=".")
compile.command=paste("admb", filename, sep=" ")
shell(compile.command)
#######Run admb
run.command <- paste(filename, admb.switch,sep=" ")
shell(run.command)
shell(paste("01cleanup.bat"))
setwd(wd)
# Chunk 13: admin
save.image(file="_05_BAM_ConvertToSpeciesSpecificData.RData")
# Chunk 14: plot results
rdat_speciesname <- paste0("rdat_",gsub(" ","",Species))
spp <- dget(file.path(dADMB,"BAMBase.rdat"))
assign(rdat_speciesname,spp)
save(list=rdat_speciesname,file=file.path(dADMB,paste0(rdat_speciesname,".RData")))
## Workarounds to deal with FishGraph issues
# FishGraph can't handle matrices with one row
spp$comp.mats$acomp.sBT.ob <- NULL
spp$comp.mats$acomp.sBT.pr <- NULL
plot_bam(spp)
setwd("~/SEDAR/BAM_DATA/MostRecentAssessment/convert_bam2rdata")
# Chunk 1: setup
rm(list=ls())
knitr::opts_chunk$set(comment=NA,echo=FALSE,message=FALSE,warning=FALSE,fig.height=8,fig.width=6)
#library(FishLife)
#library(rfishbase)
library(stringr)
#library(bamExtras) # Nikolai's package
# Chunk 2: admin
dir_bam <- "bam"
dir_RData <- "bam_RData"
# Chunk 3: read csv
# Read in values that are not supplied by BAM rdat files
bamStockMisc <- read.csv("bamStockMisc.csv")
row.names(bamStockMisc) <- bamStockMisc$Name
save(bamStockMisc,file = file.path(dir_RData,"bamStockMisc.RData"))
# Chunk 4: read bam accessory files
admb2r.cpp <- readLines("admb2r.cpp")
cleanup.bat <- readLines("cleanup.bat")
save(admb2r.cpp, file = file.path(dir_RData,"admb2r.cpp.RData"))
save(cleanup.bat, file = file.path(dir_RData,"cleanup.bat.RData"))
# Chunk 5: load bam data
bam_common_name <- sort(unique(unlist(str_extract_all(list.files(dir_bam),"^.[^.]*"))))
# Get bam rdat lists
for(fileName_i in list.files(dir_bam)){
bam_common_name_i <- unlist(str_extract_all(fileName_i,"^.[^.]*"))
ext_i <- str_extract(fileName_i,"[a-z]+$")
path_i <- file.path(dir_bam,fileName_i)
if(ext_i=="rdat"){
object_i <- dget(path_i)
}else{
object_i <- readLines(path_i)
}
objectName_i <- paste(ext_i,bam_common_name_i,sep="_")
assign(objectName_i,object_i)
# Save rdat lists as RData files
save(list=objectName_i,file=file.path(dir_RData,paste0(objectName_i,".RData")))
}
rm("objectName_i")
library(bamExtras)
library(bamExtras)
run_retro("BlackSeaBass", dir_bam_base="BlSB_base", dir_bam_sim="BlSB_sim",nyr_remove=1:4)
getwd()
setwd("~/GitHub/myPackages/bamExtras/TEST_FOLDER/run_retro")
run_retro("BlackSeaBass", dir_bam_base="BlSB_base", dir_bam_sim="BlSB_sim",nyr_remove=1:4) # removing 5 years results in an error likely due to closed season commercial pot discards running out of data
run_retro("BluelineTilefish", dir_bam_base="BlTi_base", dir_bam_sim="BlTi_sim")
run_retro("Cobia", dir_bam_base="Cobi_base", dir_bam_sim="Cobi_sim")
run_retro("GagGrouper", dir_bam_base="GaGr_base", dir_bam_sim="GaGr_sim")
run_retro("GrayTriggerfish", dir_bam_base="GrTr_base", dir_bam_sim="GrTr_sim")
run_retro("GreaterAmberjack", dir_bam_base="GrAm_base", dir_bam_sim="GrAm_sim",nyr_remove=1:4) # removing 5 years results in an error because you run out of rGN discard length comps which start in 2013
run_retro("RedGrouper", dir_bam_base="ReGr_base", dir_bam_sim="ReGr_sim")
run_retro("RedPorgy", dir_bam_base="RePo_base", dir_bam_sim="RePo_sim")
run_retro("RedSnapper", dir_bam_base="ReSn_base", dir_bam_sim="ReSn_sim")
run_retro("ScampGrouper", dir_bam_base="ScGr_base", dir_bam_sim="ScGr_sim")
run_retro("SnowyGrouper", dir_bam_base="SnGr_base", dir_bam_sim="SnGr_sim")
run_retro("Tilefish", dir_bam_base="Tile_base", dir_bam_sim="Tile_sim")
run_retro("VermilionSnapper", dir_bam_base="VeSn_base", dir_bam_sim="VeSn_sim")
180*4*8
3050-1750
