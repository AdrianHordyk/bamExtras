dim=c(length(age_i), length(years_i) , nsex, nsim),
dimnames=list("age"=age_i, "year"=years_i, "sex"=sexNames,"sim"=1:nsim)
),
c(4,1,2,3)
)
CurrentYr_i <-  parms_i$endyr
if(!is.null(ObsUser)) {
if(run_rdat2Obs){
my_rdat <- get(gsub("MOM","rdat",MOM_name_i))
ObsUser <- rdat2Obs(
rdat=my_rdat,
Obs=ObsUser,
Ind_abb=c("sTV", "sCT", "sVD", "sBL", "sVL", "sBT", "sFT"),
CAA_abb=c("sTV", "sCT", "sVD", "sBL", "sVL", "sBT", "sFT"),
CAL_abb=c("sTV", "sCT", "sVD", "sBL", "sVL", "sBT", "sFT")
)
}
}
MOM_i <- Assess2MOM(Name=Name_i,
proyears = proyears,
interval = interval,
CurrentYr = CurrentYr_i,
h=steep_i,
R0=R0_i,
#Perr=, # Can set standard deviation of recruitment
#AC=,   # Can set autocorrelation of recruitment
Obs = ObsUser,
Imp = ImpUser,
naa=naa,
faa=faa_5d,
waa=waa,
Mataa=Mataa,
Maa=Maa,
laa=laa,
nyr_par_mu = 3,
LowerTri = nyrNoRecDevEnd,
recind = 0,
plusgroup = TRUE,
altinit = 0,
fixq1 = FALSE)
# Add indices observed in the assessment, their CVs, and their selectivities
AddInd <- slot(Data_i,"AddInd")
CV_AddInd <- slot(Data_i,"CV_AddInd")
AddIndV <- slot(Data_i,"AddIndV")
AddIndType <- slot(Data_i,"AddIndType")
AddIunits <- slot(Data_i,"AddIunits")
if(AddInd_endyr_only){
# Identify which indices are available (not NA) in the terminal year of the assessment
AddInd_endyr_NA <- is.na(AddInd[1,,dim(AddInd)[3]])
if(any(!AddInd_endyr_NA)){
AddInd_endyr_ix <- which(!AddInd_endyr_NA) # Just uses the first sim, but that should be fine
}else{
message(paste(Name_i,": No indices available in the terminal year of the assessment. Using the latest index available for AddInd."))
AddInd_LastYearAvail <- apply(AddInd[1,,,drop=FALSE],2,function(x){max(which(!is.na(x)))})
AddInd_endyr_ix <- AddInd_LastYearAvail==max(AddInd_LastYearAvail)
}
AddInd <- AddInd[,AddInd_endyr_ix,,drop=FALSE]
CV_AddInd <- CV_AddInd[,AddInd_endyr_ix,,drop=FALSE]
AddIndV <- AddIndV[,AddInd_endyr_ix,,drop=FALSE]
AddIndType <- AddIndType[AddInd_endyr_ix]
AddIunits <- AddIunits[AddInd_endyr_ix]
}
Data2_i <- Data_empty()
slot(Data2_i,"AddInd") <- AddInd
slot(Data2_i,"CV_AddInd") <- CV_AddInd
slot(Data2_i,"AddIndV") <- AddIndV
slot(Data2_i,"AddIndType") <- AddIndType
slot(Data2_i,"AddIunits") <- AddIunits
# For each sublist in cpars
for(sex_i in 1:length(MOM_i@cpars)){
for(fleet_i in 1:length(MOM_i@cpars[[sex_i]])){
cpars_ii <- MOM_i@cpars[[sex_i]][[fleet_i]]
if(Mconstant){
cpars_ii$M_ageArray[] <- Data_i@Mort
}
cpars_ii$K <- rep(K_i,nsim)
cpars_ii$Linf <- rep(Linf_i,nsim)
cpars_ii$t0 <- rep(t0_i,nsim)
if(!is.na(Perr_y_user)){
cpars_ii$Perr_y[] <- Perr_y_user
}
if(Vconstant){
cpars_ii$V <- local({
V <- cpars_ii$V
V2 <- aperm(V, perm = c(2, 1, 3))
Vc <- V[1,,MOM_i@nyears+1]
V3 <- array(Vc,dim=dim(V2))
aperm(V3, perm = c(2, 1, 3))
})
}
cpars_ii$Data <- Data2_i
MOM_i@cpars[[sex_i]][[fleet_i]] <- cpars_ii
} # End cpars fleet loop
} # End cpars sex loop
list_Nage_F0_pr_sc[[Name_i]] <- Nage_F0_pr_sc
# Save rdat modifications
rdatmods_name_i <- gsub("rdat","rdatmods",rdat_name_i)
rdatmods_i <- list(
"Name"=Name_i,
"CurrentYr" = CurrentYr_i,
"steep"=steep_i,
"R0"=R0_i,
"a.series"=a.series_i,
"Nage_F0_pr_sc" = Nage_F0_pr_sc,
"N.age" = t(naa_2d[,-1]),
"F.age" = t(faa_total_2d[,-1]),
"B.age" = t(naa_2d[,-1])*t(waa_2d)
)
assign(rdatmods_name_i,rdatmods_i)
rdatmods[[Name_i]] <- rdatmods_i
assign(MOM_name_i,MOM_i)
}
save(rdatmods,file="rdatmods.RData")
minF
str(faa_3d)
faa_3d[,,3]
# Chunk 1: setup
rm(list=ls())
knitr::opts_chunk$set(comment=NA,echo=FALSE,message=FALSE,warning=FALSE,fig.height=8,fig.width=6)
library(car)
library(faux) # Simulation for Factorial Designs
# devtools::install_github("james-thorson/FishLife")
library(FishLife)
library(Hmisc)
library(MultiRNG) # Multivariate Pseudo-Random Number Generation
library(measurements) # Unit conversion functions like conv_unit()
# library(openMSE)
library(DLMtool)
library(MSEtool)
library(SAMtool)
library(rfishbase)
library(stringr)
library(bamExtras) # Nikolai's package
library(bamMSE) # Nikolai's package
# Chunk 2: user
length_sc <- 0.1 # Scalar (multiplier) to convert length units. MSEtool examples seem to use cm whereas BAM uses mm.
generate_Hist <- TRUE # Switch for running Simulate on all of the OM to generate Hist objects. (takes a while)
plot_Hist <- TRUE # Plot hist objects
plot_pdf <- TRUE
# OM
nsim <- 3 # The number of simulations (48 is the minimum number you can run in parallel)
nsex <- 1 # Number of sexes to model (for MOM)
proyears <- 50 # The number of projected years
interval <- 1  # The assessment interval - how often would you like to update the management system? (should be set to 1 when using the make_interim_MP function)
set_Fage0_to_zero <- FALSE # Should we assume F-at-age zero is zero for stocks where age zero was not modeled?
# Min F
minF <- 0.0001 # Don't let F for any fleet be less than this value in any year
# Set recruitment process error (cpars$Perr_y)
Perr_y_user <- NA # Set to 1 to remove process error (set to NA in order to leave it as it is)
# Specify observation model (Huynh et al. used the "Precise_Unbiased" Obs model)
ObsUser <- Perfect_Info
run_rdat2Obs <- TRUE   # If TRUE, OM will start with ObsUser but then run rdat2Obs on the appropriate
# rdat to modify the Obs object to reflect sampling observed in data used in BAM
# assessments
# Specify implementation model (Huynh et al. used the "Perfect_Imp" Imp model)
ImpUser <- Perfect_Imp
# Add suffix to OM names
OM_name_suffix <- ""
# Add suffix to MOM names
MOM_name_suffix <- ""
# Set vulnerability-at-age (V) to a constant vector in OM@cpars@V
Vconstant <- FALSE
# Limit maximum value of proportion mature of first age class (usually age-1)
# Some models fail when maturity of first age class is too high (e.g. >0.5)
# I think because age at 50% maturity can't really be found.
Mat_age1_max <- 0.49
# Indicate if operating models should only include indices that were available in the final year of the assessment. logical
AddInd_endyr_only <- TRUE
## Do not use age-varying M (since SCA uses constant M)
#!! As of 2022-03-24 the run_script for the MSE is expecting OM with age-varying M.
#!! M is then set to constant in most scenarios in the MSE
Mconstant <- FALSE
# # par_cv: When generating parameters for Stock objects, mean values are observed from rdat.
# #         Coefficient of variation (CV) values are set to compute the standard deviation of
# #         a normal distribution from which to sample parameter values
# par_cv <- c("TLinfinity"=0.1,"K"=0.1,"M"=0.1)
#
# # OM
# Agency <- "NMFS SEFSC"
# Region <- "Southeast US Atlantic"
# Sponsor <- "none"
# Latitude <-  mean(c(25.0,35.6))
# Longitude <- mean(c(-81.5,-74.0))
# nsim <- 250 # The number of simulations (48 is the minimum number you can run in parallel)
# proyears <- 50 # The number of projected years
# interval <- 1  # The assessment interval - how often would you like to update the management system? (should be set to 1 when using the make_interim_MP function using)
# pstar <- 0.5 # The percentile of the sample of the management recommendation for each method
# maxF <- 3.0 # Maximum instantaneous fishing mortality rate that may be simulated for any given age class
# reps <- 1 # Number of samples of the management recommendation for each method. Note that when this is set to 1, the mean value of the data inputs is used
bam_common_name_sub <- c(
"BlackSeaBass",
"BluelineTilefish",
"Cobia",
"GagGrouper",
"GrayTriggerfish",
"GreaterAmberjack",
#"MenhadenAtl",
"RedGrouper",
"RedPorgy",
"RedSnapper",
"SnowyGrouper",
#"SpanishMackerel",
"Tilefish",
"VermilionSnapper"
)
bam_rdat_name <- paste("rdat",bam_common_name_sub,sep="_")
OMNames <- gsub("rdat_","OM_",bam_rdat_name)
# Names of sexes in MOM
sexNames <- list("unisex",c("female","male"))[[nsex]]
# Chunk 3: functions
# color function like rainbow() but without yellow (or indigo)
blues <- colorRampPalette(c("darkblue","lightblue"))
grays <- colorRampPalette(c("black","lightgray"))
# Chunk 4: build Data
for(rdat_name_i in bam_rdat_name){
rdat_i <- get(rdat_name_i)
Data_name_i <- gsub("rdat","Data",rdat_name_i)
Data_i <- rdat2Data(rdat_i, Mat_age1_max=Mat_age1_max, length_sc = length_sc,nsim=nsim, AddInd_order = "CVlo")
assign(Data_name_i,Data_i)
saveRDS(Data_i,file=file.path("Data","SEFSC",paste0(Data_name_i,".rds")),compress=FALSE)
}
# Chunk 5: build MOM Assess2MOM
rdatmods <- list() # List for saving rdat modifications used when plotting bam results compared with Hist objects
list_Nage_F0_pr_sc <- list() # List for storing values of Nage_F0_pr_sc (for plotting hist compared to BAM)
vec2mat <- function(vec,naa){
matrix(vec,nrow=dim(naa)[2],ncol=dim(naa)[3],byrow=FALSE,
dimnames=dimnames(naa)[2:3])
}
mat2array <- function(mat,nsim){
mat_data <- rep(as.numeric(mat),each=nsim)
array(mat_data, dim=c(nsim,nrow(mat),ncol(mat)),
dimnames=list("sim"=1:nsim, "ages"=rownames(mat), "year"=colnames(mat)))
}
for(rdat_name_i in bam_rdat_name[1]){
sexNames <- list("unisex",c("female","male"))[[nsex]]
rdat_i <- standardize_rdat(get(rdat_name_i))
rdat_i <- add2rdat(rdat_i)
Name_i <- gsub("rdat_","",rdat_name_i)
DataName_i <- gsub("rdat_","Data_",rdat_name_i)
Data_i <- get(DataName_i)
Obs_i <- rdat2Obs(rdat_i)
herm_i <- bamStockMisc[Name_i, "herm"]
MOM_name_i <- gsub("rdat","MOM",rdat_name_i)
a.series_i <- rdat_i$a.series
t.series_i <- rdat_i$t.series
ageinit_i <- a.series_i$age
ageinitmin_i <- min(ageinit_i)
parms_i <- rdat_i$parms
parm.cons_i <- rdat_i$parm.cons
years_i <- paste(parms_i$styr:parms_i$endyr)
Linf_i <- parm.cons_i$Linf[8]*length_sc
K_i <- parm.cons_i$K[8]
t0_i <- parm.cons_i$t0[8]
steep_i <- parm.cons_i$steep[8]
R0_i <- exp(parm.cons_i$log.R0[8])
F.age.fleet_i <- rdat_i$F.age.fleet
# Compute the number of years at the end of the assessment where rec devs weren't estimated
nyrNoRecDevEnd <- if (any(t.series_i$logR.dev!=0)) {
length(t.series_i$logR.dev)-max(which(t.series_i$logR.dev!=0))}else{
1
}
if(min(ageinit_i)>0){
warning(paste(Name_i,": Minimum age > 0. Age-based data extrapolated to age-0"))
a.series_i <- data_polate(a.series_i,xout=0:max(a.series_i$age))
a.series_i <- data_lim(a.series_i,xlim=c(0,Inf))
a.series_i <- data_lim(a.series_i,xname=c("prop.female","prop.male","mat.female","mat.male"),xlim=c(0,1))
a.series_i <- as.data.frame(a.series_i)
rownames(a.series_i) <- a.series_i$age
}
age_i <- a.series_i$age
# NOTE: this will have no effect in ageinitmin_i=0
Nage_F0_pr <- exp_decay(age=age_i,Z=a.series_i$M,N0=1)                  # Unfished N-at-age per recruit
Nage_F0_pr_sc <- (Nage_F0_pr/Nage_F0_pr[[paste(ageinitmin_i)]])[["0"]] # Scaling factor for computing unfished numbers at age-0
R0_i <- R0_i*Nage_F0_pr_sc                                             # Scaled value of R0
naa_2d <- local({
a <- cbind("age"=ageinit_i,t(rdat_i$N.age[years_i,]))
b <- data_polate(a,xout = age_i)
rownames(b) <- age_i
b["0",-1] <- b[paste(ageinitmin_i),-1]*Nage_F0_pr_sc # Compute numbers at age-0
b[b<0] <- 1 # Don't let value be less than 1
b
})
if(nsex==1){
naa <- mat2array(naa_2d[,-1],nsim=nsim)
naa <- aperm(array(naa,
dim=c(length(years_i),length(age_i),nsex,nsim),
dimnames=list("year"=years_i,"age"=age_i,"sex"=sexNames,"sim"=1:nsim)
),
c(4,2,1,3)
)
}
if(nsex==2){
naa <- mat2array(naa_2d[,-1],nsim=nsim)
naa_fem <- aperm(aperm(naa,c(2,1,3))*(  a.series_i$prop.female),c(2,1,3))
naa_mal <- aperm(aperm(naa,c(2,1,3))*(1-a.series_i$prop.female),c(2,1,3))
naa <- abind::abind(naa_fem,naa_mal,along=4)
}
dimnames(naa) <- list("sim"=1:nsim, "ages"=age_i, "year"=years_i,"sex"=sexNames)
# F-at-age combined
faa_total_2d <- local({
a <- cbind("age"=ageinit_i,t(rdat_i$F.age[years_i,]))
b <- data_polate(a,xout = age_i)
rownames(b) <- age_i
if(set_Fage0_to_zero){
b["0",-1] <- 0 # Set F at age-0 to zero
}
b[b<=minF] <- minF # Don't let F be less than minF
b
})
# F-at-age by fleet array
Faf <- rdat_i$F.age.fleet
faa_3d <- array(as.numeric(unlist(Faf)),
dim=c(length(years_i),length(age_i),length(Faf)),
dimnames=list("year"=years_i,"age"=age_i,"fleet"=names(Faf))
)
if(set_Fage0_to_zero){
faa_3d[,"0",] <- 0 # Set F at age-0 to zero
}
faa_3d[faa_3d<=minF] <- minF # Don't let F be less than minF
# Note that when filling arrays, the data vector fills by column, and recycles the data until
# the whole array is filled
faa_5d <- aperm(
array(rep(as.numeric(faa_3d),nsex*nsim),
dim=c(length(years_i),length(age_i),length(Faf),nsex,nsim),
dimnames=list("year"=years_i,"age"=age_i,"fleet"=names(Faf),"sex"=sexNames,"sim"=1:nsim)
),
c(5,2,1,4,3)
)
# Weight (klb) at-age matrix
waa_2d <- matrix(a.series_i$wgt.klb,
nrow=length(age_i),ncol=length(years_i),byrow=FALSE,
dimnames=list(age_i,years_i))
# Weight (klb) at-age array
waa <- aperm(
array(a.series_i$wgt.klb,
dim=c(length(age_i), length(years_i) , nsex, nsim),
dimnames=list("age"=age_i, "year"=years_i, "sex"=sexNames,"sim"=1:nsim)
),
c(4,1,2,3)
)
# Maturity-at-age array
if(nsex==1){
pmatage_i <- pmatage(a.series_i,herm=herm_i)$pmat
}
if(nsex==2){
mat_fem_i <- setNames(a.series_i$mat.female,age_i)
# If male maturity is provided use it
if("mat.male"%in%names(a.series_i)){
mat_mal_i <- setNames(a.series_i$mat.male,age_i)
}else{
if(herm_i=="protogynous"){
mat_mal_i <- setNames(rep(1,nrow(a.series_i)),age_i) # if protogynous assume all males are mature
}else{
mat_mal_i <- setNames(mat_fem_i,age_i)   # if gonochoristic assume male maturity is equal to female maturity
}
}
# Limit maximum proportion mature at first age to Mat_age1_max
mat_fem_i <- pmin(mat_fem_i,Mat_age1_max)
mat_mal_i <- pmin(mat_mal_i,Mat_age1_max)
pmatage_i <- c(mat_fem_i,mat_mal_i)
}
Mataa <- aperm(
array(pmatage_i,
dim=c(length(age_i), nsex, length(years_i) , nsim),
dimnames=list("age"=age_i, "sex"=sexNames, "year"=years_i, "sim"=1:nsim)
),
c(4,1,3,2)
)
# Natural mortality at age array
Maa <- aperm(
array(a.series_i$M,
dim=c(length(age_i), length(years_i) , nsex, nsim),
dimnames=list("age"=age_i, "year"=years_i, "sex"=sexNames,"sim"=1:nsim)
),
c(4,1,2,3)
)
# Length at age array
laa <- aperm(
array(a.series_i$length*length_sc,
dim=c(length(age_i), length(years_i) , nsex, nsim),
dimnames=list("age"=age_i, "year"=years_i, "sex"=sexNames,"sim"=1:nsim)
),
c(4,1,2,3)
)
CurrentYr_i <-  parms_i$endyr
if(!is.null(ObsUser)) {
if(run_rdat2Obs){
my_rdat <- get(gsub("MOM","rdat",MOM_name_i))
ObsUser <- rdat2Obs(
rdat=my_rdat,
Obs=ObsUser,
Ind_abb=c("sTV", "sCT", "sVD", "sBL", "sVL", "sBT", "sFT"),
CAA_abb=c("sTV", "sCT", "sVD", "sBL", "sVL", "sBT", "sFT"),
CAL_abb=c("sTV", "sCT", "sVD", "sBL", "sVL", "sBT", "sFT")
)
}
}
MOM_i <- Assess2MOM(Name=Name_i,
proyears = proyears,
interval = interval,
CurrentYr = CurrentYr_i,
h=steep_i,
R0=R0_i,
#Perr=, # Can set standard deviation of recruitment
#AC=,   # Can set autocorrelation of recruitment
Obs = ObsUser,
Imp = ImpUser,
naa=naa,
faa=faa_5d,
waa=waa,
Mataa=Mataa,
Maa=Maa,
laa=laa,
nyr_par_mu = 3,
LowerTri = nyrNoRecDevEnd,
recind = 0,
plusgroup = TRUE,
altinit = 0,
fixq1 = FALSE)
# Add indices observed in the assessment, their CVs, and their selectivities
AddInd <- slot(Data_i,"AddInd")
CV_AddInd <- slot(Data_i,"CV_AddInd")
AddIndV <- slot(Data_i,"AddIndV")
AddIndType <- slot(Data_i,"AddIndType")
AddIunits <- slot(Data_i,"AddIunits")
if(AddInd_endyr_only){
# Identify which indices are available (not NA) in the terminal year of the assessment
AddInd_endyr_NA <- is.na(AddInd[1,,dim(AddInd)[3]])
if(any(!AddInd_endyr_NA)){
AddInd_endyr_ix <- which(!AddInd_endyr_NA) # Just uses the first sim, but that should be fine
}else{
message(paste(Name_i,": No indices available in the terminal year of the assessment. Using the latest index available for AddInd."))
AddInd_LastYearAvail <- apply(AddInd[1,,,drop=FALSE],2,function(x){max(which(!is.na(x)))})
AddInd_endyr_ix <- AddInd_LastYearAvail==max(AddInd_LastYearAvail)
}
AddInd <- AddInd[,AddInd_endyr_ix,,drop=FALSE]
CV_AddInd <- CV_AddInd[,AddInd_endyr_ix,,drop=FALSE]
AddIndV <- AddIndV[,AddInd_endyr_ix,,drop=FALSE]
AddIndType <- AddIndType[AddInd_endyr_ix]
AddIunits <- AddIunits[AddInd_endyr_ix]
}
Data2_i <- Data_empty()
slot(Data2_i,"AddInd") <- AddInd
slot(Data2_i,"CV_AddInd") <- CV_AddInd
slot(Data2_i,"AddIndV") <- AddIndV
slot(Data2_i,"AddIndType") <- AddIndType
slot(Data2_i,"AddIunits") <- AddIunits
# For each sublist in cpars
for(sex_i in 1:length(MOM_i@cpars)){
for(fleet_i in 1:length(MOM_i@cpars[[sex_i]])){
cpars_ii <- MOM_i@cpars[[sex_i]][[fleet_i]]
if(Mconstant){
cpars_ii$M_ageArray[] <- Data_i@Mort
}
cpars_ii$K <- rep(K_i,nsim)
cpars_ii$Linf <- rep(Linf_i,nsim)
cpars_ii$t0 <- rep(t0_i,nsim)
if(!is.na(Perr_y_user)){
cpars_ii$Perr_y[] <- Perr_y_user
}
if(Vconstant){
cpars_ii$V <- local({
V <- cpars_ii$V
V2 <- aperm(V, perm = c(2, 1, 3))
Vc <- V[1,,MOM_i@nyears+1]
V3 <- array(Vc,dim=dim(V2))
aperm(V3, perm = c(2, 1, 3))
})
}
cpars_ii$Data <- Data2_i
MOM_i@cpars[[sex_i]][[fleet_i]] <- cpars_ii
} # End cpars fleet loop
} # End cpars sex loop
list_Nage_F0_pr_sc[[Name_i]] <- Nage_F0_pr_sc
# Save rdat modifications
rdatmods_name_i <- gsub("rdat","rdatmods",rdat_name_i)
rdatmods_i <- list(
"Name"=Name_i,
"CurrentYr" = CurrentYr_i,
"steep"=steep_i,
"R0"=R0_i,
"a.series"=a.series_i,
"Nage_F0_pr_sc" = Nage_F0_pr_sc,
"N.age" = t(naa_2d[,-1]),
"F.age" = t(faa_total_2d[,-1]),
"B.age" = t(naa_2d[,-1])*t(waa_2d)
)
assign(rdatmods_name_i,rdatmods_i)
rdatmods[[Name_i]] <- rdatmods_i
assign(MOM_name_i,MOM_i)
}
save(rdatmods,file="rdatmods.RData")
# Chunk 8: save MOM
MOM_name_bam <- gsub("rdat","MOM",bam_rdat_name) # MOM names from bam models
for(MOM_name_i in MOM_name_bam){
MOM_i <- get(MOM_name_i)
if(MOM_name_i%in%MOM_name_bam){  saveRDS(MOM_i,file=file.path("MOM","SEFSC",paste0(MOM_name_i,MOM_name_suffix,".rds")),compress=FALSE)
}
}
# Chunk 9: generate Hist
if(generate_Hist){
for(MOM_name_i in MOM_name_bam){
MOM_i <- get(MOM_name_i)
cat(paste0("\n\nWorking on ",MOM_name_i,"\n"))
Hist_i <- multiMSE(MOM_i, Hist = TRUE, parallel = FALSE, checkMPs = FALSE)
if(MOM_name_i%in%MOM_name_bam){
Hist_name_i <- gsub("MOM","Hist",MOM_name_i)
assign(Hist_name_i,Hist_i)
saveRDS(Hist_i, file = file.path("Hist","SEFSC",paste0(Hist_name_i,".rds")))
}
}
}
